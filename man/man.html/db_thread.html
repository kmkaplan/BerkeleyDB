<HTML>
<HEAD>
<TITLE>db_thread</TITLE>
</HEAD>
<BODY>
<H1>db_thread</H1>
<HR>
<PRE>

</PRE>
<H2>NAME</H2><PRE>
       db_thread - using threads in the DB library.


</PRE>
<H2>DESCRIPTION</H2><PRE>
       The  DB  library  is  a family of groups of functions that
       provides a modular programming interface  to  transactions
       and  record-oriented  file  access.   The library includes
       support for transactions, locking, logging and  file  page
       caching,  as well as various indexed access methods.  Many
       of the functional groups  (e.g.,  the  file  page  caching
       functions)  are  useful  independent of the other DB func-
       tions, although  some  functional  groups  are  explicitly
       based  on  other functional groups (e.g., transactions and
       logging).  For a general description of  the  DB  package,
       see <STRONG><A HREF="db_intro.html">db_intro(3)</A></STRONG>.

       This  manual pages describes the specific details of using
       DB from within threaded programs.

       The DB library is not itself multi-threaded.  The  library
       was deliberately architected to not use threads internally
       because of the portability  problems  that  using  threads
       within   the  library  would  introduce.   Object  handles
       returned from  DB  library  functions  are  free-threaded,
       i.e.,  threads may use handles concurrently, by specifying
       the DB_THREAD flag to <STRONG><A HREF="db_appinit.html">db_appinit(3)</A></STRONG> (or, in the  C++  API,
       <EM>DbEnv::</EM><STRONG><A HREF="appinit.html">appinit(3)</A></STRONG>) and the other subsystem open functions.

       DB supports multi-threaded applications  with  the  caveat
       that it loads and calls functions that are commonly avail-
       able in C language environments and which  may  not  them-
       selves  be  thread-safe.  Other than this usage, DB has no
       static data and maintains no local context  between  calls
       to  DB  functions.  To ensure that applications can safely
       use threads in the context of DB, porters to new operating
       systems  and/or  C  libraries must confirm that the system
       and C library functions used by the DB library are thread-
       safe.

       There  are  some additional caveats about using threads to
       access the DB library:

       <STRONG>o</STRONG> The DB_THREAD flag must be specified for all  subsystems
         either explicitly or via the <EM>db</EM><STRONG>_</STRONG><EM>appinit</EM> (<EM>DbEnv::appinit</EM>)
         function.  Setting the DB_THREAD flag inconsistently may
         result in database corruption.

       <STRONG>o</STRONG> Only  a  single thread may call the close function for a
         returned database or subsystem handle.   See  <STRONG><A HREF="db_open.html">db_open(3)</A></STRONG>
         (<EM>Db::</EM><STRONG><A HREF="open.html">open(3)</A></STRONG>) and the appropriate subsystem manual pages
         for more information.

       <STRONG>o</STRONG> Either the DB_DBT_MALLOC or DB_DBT_USERMEM flags must be
         set  in  a  DBT  used  for  key  or data retrieval.  See
         on behalf of a  unique  locker.   If,  within  a  single
         thread  of control, multiple calls on behalf of the same
         locker are desired, then transactions must be used.  For
         example, consider the case where a cursor scan locates a
         record, and then based on  that  record,  accesses  some
         other item in the database.  If these are done using the
         default lockers for the handle, there  is  no  guarantee
         that  these  two  operations  will not conflict.  If the
         application wishes to guarantee that the  operations  do
         not  conflict,  locks  must  be  obtained on behalf of a
         transaction, instead of the default  locker  id,  and  a
         transaction must be specified to the cursor creation and
         the subsequent db call.

       <STRONG>o</STRONG> Transactions may not span threads, i.e.,  each  transac-
         tion  must  begin  and  end in the same thread, and each
         transaction may only be used by a single thread.

       <STRONG>o</STRONG> Spinlocks  must  have  been  implemented  for  the  com-
         piler/architecture  combination.   Attempting to specify
         the DB_THREAD flag will fail if spinlocks are not avail-
         able.

       <STRONG>o</STRONG> The  DB  library  makes  a system call to pause for some
         number of microseconds when it is necessary to wait on a
         lock.   This may not be optimal, especially in a thread-
         only environment where it  will  be  more  efficient  to
         explicitly yield the processor to another thread.  It is
         possible to specify a yield function on an  per-applica-
         tion basis, see <STRONG><A HREF="db_jump.html">db_jump(3)</A></STRONG> for more information.


</PRE>
<H2>COMPILING THREADED APPLICATIONS</H2><PRE>
       Special  compile-time  flags  are  required when compiling
       threaded applications with the UNIX include files on  some
       architectures.

       On  IRIX, if you are compiling a threaded application, you
       must compile with the -D_SGI_MP_SOURCE flag:

            cc -D_SGI_MP_SOURCE ...

       On OSF/1, if you are compiling a threaded application, you
       must compile with the -D_REENTRANT flag:

            cc -D_REENTRANT ...

       On  Solaris,  if you are compiling a threaded application,
       you must compile with the -D_REENTRANT flag and link  with
       the -lthread library:

            cc -D_REENTRANT ... -lthread


</PRE>
<H2>SEE ALSO</H2><PRE>
       <STRONG><A HREF="db_archive.html">db_archive(1)</A></STRONG>, <STRONG><A HREF="db_checkpoint.html">db_checkpoint(1)</A></STRONG>, <STRONG><A HREF="db_deadlock.html">db_deadlock(1)</A></STRONG>, <STRONG><A HREF="db_dump.html">db_dump(1)</A></STRONG>,
</PRE>
</BODY>
</HTML>
