<HTML>
<HEAD>
<TITLE>db_open</TITLE>
</HEAD>
<BODY>
<H1>db_open</H1>
<HR>
<PRE>

</PRE>
<H2>NAME</H2><PRE>
       db_open - database access methods


</PRE>
<H2>SYNOPSIS</H2><PRE>
       <STRONG>#include</STRONG> <STRONG>&lt;db.h&gt;</STRONG>

       <STRONG>int</STRONG>
       <STRONG>db_open(const</STRONG> <STRONG>char</STRONG> <STRONG>*file,</STRONG> <STRONG>DBTYPE</STRONG> <STRONG>type,</STRONG>
            <STRONG>int</STRONG> <STRONG>flags,</STRONG> <STRONG>int</STRONG> <STRONG>mode,</STRONG> <STRONG>DB_ENV</STRONG> <STRONG>*dbenv,</STRONG> <STRONG>DB_INFO</STRONG> <STRONG>*dbinfo,</STRONG> <STRONG>DB</STRONG> <STRONG>**dbpp);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DB-&gt;close(DB</STRONG> <STRONG>*db,</STRONG> <STRONG>int</STRONG> <STRONG>flags);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DB-&gt;cursor(DB</STRONG> <STRONG>*db,</STRONG> <STRONG>DB_TXN</STRONG> <STRONG>*txnid,</STRONG> <STRONG>DBC</STRONG> <STRONG>**cursorp);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DB-&gt;del(DB</STRONG> <STRONG>*db,</STRONG> <STRONG>DB_TXN</STRONG> <STRONG>*txnid,</STRONG> <STRONG>DBT</STRONG> <STRONG>*key,</STRONG> <STRONG>int</STRONG> <STRONG>flags);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DB-&gt;fd(DB</STRONG> <STRONG>*db,</STRONG> <STRONG>int</STRONG> <STRONG>*fdp);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DB-&gt;get(DB</STRONG> <STRONG>*db,</STRONG> <STRONG>DB_TXN</STRONG> <STRONG>*txnid,</STRONG> <STRONG>DBT</STRONG> <STRONG>*key,</STRONG> <STRONG>DBT</STRONG> <STRONG>*data,</STRONG> <STRONG>int</STRONG> <STRONG>flags);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DB-&gt;put(DB</STRONG> <STRONG>*db,</STRONG> <STRONG>DB_TXN</STRONG> <STRONG>*txnid,</STRONG> <STRONG>DBT</STRONG> <STRONG>*key,</STRONG> <STRONG>DBT</STRONG> <STRONG>*data,</STRONG> <STRONG>int</STRONG> <STRONG>flags);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DB-&gt;sync(DB</STRONG> <STRONG>*db,</STRONG> <STRONG>int</STRONG> <STRONG>flags);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DB-&gt;stat(DB</STRONG> <STRONG>*db,</STRONG> <STRONG>void</STRONG> <STRONG>*sp,</STRONG> <STRONG>void</STRONG> <STRONG>*(*db_malloc)(size_t),</STRONG> <STRONG>int</STRONG> <STRONG>flags);</STRONG>


</PRE>
<H2>DESCRIPTION</H2><PRE>
       The  DB  library  is  a family of groups of functions that
       provides a modular programming interface  to  transactions
       and  record-oriented  file  access.   The library includes
       support for transactions, locking, logging and  file  page
       caching,  as well as various indexed access methods.  Many
       of the functional groups  (e.g.,  the  file  page  caching
       functions)  are  useful  independent of the other DB func-
       tions, although  some  functional  groups  are  explicitly
       based  on  other functional groups (e.g., transactions and
       logging).  For a general description of  the  DB  package,
       see <STRONG><A HREF="db_intro.html">db_intro(3)</A></STRONG>.

       This manual page describes the overall structure of the DB
       library access methods.

       The currently supported file formats are btree, hashed and
       recno.   The btree format is a representation of a sorted,
       balanced tree structure.  The hashed format is an extensi-
       ble,  dynamic  hashing  scheme.  The recno format supports

       The  <EM>db</EM><STRONG>_</STRONG><EM>open</EM>  function  copies a pointer to a DB structure
       (as typedef'd in the &lt;db.h&gt; include file), into the memory
       location  referenced  by  <EM>dbpp</EM>.  This structure includes a
       set of functions to perform various database  actions,  as
       described  below.   The <EM>db</EM><STRONG>_</STRONG><EM>open</EM> function returns the value
       of <EM>errno</EM> on failure and 0 on success.

       Note, while most of the access methods  use  <EM>file</EM>  as  the
       name  of  an  underlying file on disk, this is not guaran-
       teed.  Also, calling <EM>db</EM><STRONG>_</STRONG><EM>open</EM>  is  a  reasonably  expensive
       operation.  (This is based on a model where the DBMS keeps
       a set of files open for a long time  rather  than  opening
       and closing them on each query.)

       The  <EM>type</EM>  argument  is  of type DBTYPE (as defined in the
       &lt;db.h&gt; include file) and must be set to one  of  DB_BTREE,
       DB_HASH,  DB_RECNO  or DB_UNKNOWN.  If <EM>type</EM> is DB_UNKNOWN,
       the database must already  exist  and  <EM>db</EM><STRONG>_</STRONG><EM>open</EM>  will  then
       determine  if it is of type DB_BTREE, DB_HASH or DB_RECNO.

       The <EM>flags</EM> and <EM>mode</EM> arguments specify  how  files  will  be
       opened  and/or created when they don't already exist.  The
       flags value is specified by <STRONG>or</STRONG>'ing together one or more of
       the following values:

       DB_CREATE
            Create  any  underlying  files, as necessary.  If the
            files do not already exist and the DB_CREATE flag  is
            not specified, the call will fail.

       DB_NOMMAP
            Do  not  map  this  file (see <STRONG><A HREF="db_mpool.html">db_mpool(3)</A></STRONG> for further
            information).

       DB_RDONLY
            Open the database for reading only.  Any  attempt  to
            write the database using the access methods will fail
            regardless of the actual permissions of any  underly-
            ing files.


       DB_THREAD
            Cause  the DB handle returned by the <EM>db</EM><STRONG>_</STRONG><EM>open</EM> function
            to be useable by multiple  threads  within  a  single
            address space, i.e., to be ``free-threaded''.

       DB_TRUNCATE
            ``Truncate''  the database if it exists, i.e., behave
            as if the database were just created, discarding  any
            previous contents.

       All  files  created by the access methods are created with
       mode <EM>mode</EM> (as described in <STRONG><A HREF="chmod.html">chmod(2)</A></STRONG>) and modified  by  the
       patibility with future releases of DB, all fields  of  the
       DB_ENV  structure  that  are  not explicitly set should be
       initialized to 0 before the first time  the  structure  is
       used.   Do  this  by  declaring  the structure external or
       static, or by calling the C library  routine  <STRONG><A HREF="bzero.html">bzero(3)</A></STRONG>  or
       <STRONG><A HREF="memset.html">memset(3)</A></STRONG>.

       The  fields  of  the  DB_ENV structure used by <EM>db</EM><STRONG>_</STRONG><EM>open</EM> are
       described below.  As references to  the  DB_ENV  structure
       may  be  maintained  by  <EM>db</EM><STRONG>_</STRONG><EM>open</EM>, it is necessary that the
       DB_ENV structure and memory it references be  valid  until
       the  <EM>close</EM> function is called.  If <EM>dbenv</EM> is NULL or any of
       its fields are set to 0, defaults appropriate for the sys-
       tem are used where possible.

       The  following  fields in the DB_ENV structure may be ini-
       tialized before calling <EM>db</EM><STRONG>_</STRONG><EM>open</EM>:

       DB_LOG *lg_info;
            If modifications to the file being opened  should  be
            logged,  the  <EM>lg</EM><STRONG>_</STRONG><EM>info</EM>  field  contains a return value
            from the function <EM>log</EM><STRONG>_</STRONG><EM>open</EM>.  If <EM>lg</EM><STRONG>_</STRONG><EM>info</EM> is  NULL,  no
            logging is done by the DB access methods.

       DB_LOCKTAB *lk_info;
            If  locking is required for the file being opened (as
            is the case when multiple processes  or  threads  are
            accessing  the same file), the <EM>lk</EM><STRONG>_</STRONG><EM>info</EM> field contains
            a return  value  from  the  function  <EM>lock</EM><STRONG>_</STRONG><EM>open</EM>.   If
            <EM>lk</EM><STRONG>_</STRONG><EM>info</EM>  is NULL, no locking is done by the DB access
            methods.

            If both locking and transactions are being  performed
            (i.e.,  both  <EM>lk</EM><STRONG>_</STRONG><EM>info</EM>  and <EM>tx</EM><STRONG>_</STRONG><EM>info</EM> are non-NULL), the
            transaction ID will be used as  the  locker  ID.   If
            only locking is being performed, <EM>db</EM><STRONG>_</STRONG><EM>open</EM> will acquire
            a locker ID from <STRONG><A HREF="lock_id.html">lock_id(3)</A></STRONG>, and will use it for  all
            locks required for this instance of <EM>db</EM><STRONG>_</STRONG><EM>open</EM>.

       DB_MPOOL *mp_info;
            If  the  cache  for  the  file being opened should be
            maintained in a shared buffer pool, the <EM>mp</EM><STRONG>_</STRONG><EM>info</EM> field
            contains  a return value from the function <EM>memp</EM><STRONG>_</STRONG><EM>open</EM>.
            If <EM>mp</EM><STRONG>_</STRONG><EM>info</EM> is NULL, a memory pool may still  be  cre-
            ated by DB, but it will be private to the application
            and managed by DB.

       DB_TXNMGR *tx_info;
            If the accesses to the file being opened should  take
            place in the context of transactions (providing atom-
            icity and error recovery), the <EM>tx</EM><STRONG>_</STRONG><EM>info</EM> field contains
            a  return  value  from  the  function  <EM>txn</EM><STRONG>_</STRONG><EM>open</EM>  (see
            <STRONG><A HREF="db_txn.html">db_txn(3)</A></STRONG>).   If  transactions  are  specified,   the
            application  is responsible for making suitable calls


</PRE>
<H2>DB_INFO</H2><PRE>
       The  access  methods are configured using the DB_INFO data
       structure argument to <EM>db</EM><STRONG>_</STRONG><EM>open</EM>.  The DB_INFO  structure  is
       typedef'd in &lt;db.h&gt; and has a large number of fields, most
       specific to a single access method,  although  a  few  are
       shared.   The fields that are common to all access methods
       are listed here; those specific to  an  individual  access
       method  are  described below.  No reference to the DB_INFO
       structure is maintained by DB, so it is possible  to  dis-
       card it as soon as the <EM>db</EM><STRONG>_</STRONG><EM>open</EM> call returns.

       In  order  to ensure compatibility with future releases of
       DB, all fields of the DB_INFO structure should be initial-
       ized  to  0  before  the  structure  is  used.  Do this by
       declaring the structure external or static, or by  calling
       the C library function <STRONG><A HREF="bzero.html">bzero(3)</A></STRONG> or <STRONG><A HREF="memset.html">memset(3)</A></STRONG>.


       If  possible, defaults appropriate for the system are used
       for the DB_INFO fields if <EM>dbinfo</EM> is NULL or any fields  of
       the DB_INFO structure are set to 0.  The following DB_INFO
       fields may be initialized before calling <EM>db</EM><STRONG>_</STRONG><EM>open</EM>:

       size_t db_cachesize;
            A suggested maximum size of the memory pool cache, in
            bytes.   If <EM>db</EM><STRONG>_</STRONG><EM>cachesize</EM> is 0, an appropriate default
            is used.  If the <EM>mp</EM><STRONG>_</STRONG><EM>info</EM>  field  is  also  specified,
            this field is ignored.

            <STRONG>Note,</STRONG> <STRONG>the</STRONG> <STRONG>minimum</STRONG> <STRONG>number</STRONG> <STRONG>of</STRONG> <STRONG>pages</STRONG> <STRONG>in</STRONG> <STRONG>the</STRONG> <STRONG>cache</STRONG> <STRONG>should</STRONG>
            <STRONG>be</STRONG> <STRONG>no</STRONG> <STRONG>less</STRONG> <STRONG>than</STRONG> <STRONG>10,</STRONG> <STRONG>and</STRONG> <STRONG>the</STRONG> <STRONG>access</STRONG> <STRONG>methods</STRONG> <STRONG>will</STRONG>  <STRONG>fail</STRONG>
            <STRONG>if</STRONG>  <STRONG>an</STRONG>  <STRONG>insufficiently</STRONG>  <STRONG>large</STRONG> <STRONG>cache</STRONG> <STRONG>is</STRONG> <STRONG>specified.</STRONG>  In
            addition, for applications that exhibit strong local-
            ity  in  their  data  access patterns, increasing the
            size of the cache can significantly improve  applica-
            tion performance.

       int db_lorder;
            The  byte  order  for integers in the stored database
            metadata.  The number should represent the  order  as
            an integer, for example, big endian order is the num-
            ber 4,321, and little  endian  order  is  the  number
            1,234.   If  <EM>db</EM><STRONG>_</STRONG><EM>lorder</EM>  is  0,  the host order of the
            machine where the DB library was compiled is used.

            The  value  of  <EM>db</EM><STRONG>_</STRONG><EM>lorder</EM>  is  ignored  except   when
            databases  are  being created.  If a database already
            exists, the byte order it uses is determined when the
            file is read.

            <STRONG>The</STRONG>  <STRONG>access</STRONG>  <STRONG>methods</STRONG>  <STRONG>provide</STRONG> <STRONG>no</STRONG> <STRONG>guarantees</STRONG> <STRONG>about</STRONG> <STRONG>the</STRONG>
            <STRONG>byte</STRONG> <STRONG>ordering</STRONG> <STRONG>of</STRONG> <STRONG>the</STRONG> <STRONG>application</STRONG> <STRONG>data</STRONG> <STRONG>stored</STRONG>  <STRONG>in</STRONG>  <STRONG>the</STRONG>
            <STRONG>database,</STRONG>  <STRONG>and</STRONG> <STRONG>applications</STRONG> <STRONG>are</STRONG> <STRONG>responsible</STRONG> <STRONG>for</STRONG> <STRONG>main-</STRONG>
            The flag DB_DBT_MALLOC, when  specified  in  the  DBT
            structure, will cause the DB library to allocate mem-
            ory which then  becomes  the  responsibility  of  the
            calling application.  See <STRONG><A HREF="db_dbt.html">db_dbt(3)</A></STRONG> for more informa-
            tion.

            On systems where separate heaps  are  maintained  for
            applications  and  libraries  (notably  Windows  NT),
            specifying the DB_DBT_MALLOC flag will  fail  because
            the  DB library will allocate memory from a different
            heap than the application will use to  free  it.   To
            avoid this problem, the <EM>db</EM><STRONG>_</STRONG><EM>malloc</EM> field should be set
            to point to the application's allocation routine.  If
            <EM>db</EM><STRONG>_</STRONG><EM>malloc</EM>  is  non-NULL,  it will be used to allocate
            the memory returned when the  DB_DBT_MALLOC  flag  is
            set.   The  <EM>db</EM><STRONG>_</STRONG><EM>malloc</EM> function must match the calling
            conventions of the <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG> library routine.


</PRE>
<H2>BTREE</H2><PRE>
       The btree data structure is a sorted, balanced tree struc-
       ture  storing associated key/data pairs.  Searches, inser-
       tions, and deletions in the btree will all complete  in  O
       (lg  base  N) where base is the average number of keys per
       page.  Often, inserting ordered data into  btrees  results
       in pages that are half-full.  This implementation has been
       modified to make ordered (or  inverse  ordered)  insertion
       the best case, resulting in nearly perfect page space uti-
       lization.

       Space freed by deleting key/data pairs from  the  database
       is  never  reclaimed  from  the filesystem, although it is
       reused where possible.  This means that the btree  storage
       structure  is  grow-only.   If  sufficiently many keys are
       deleted from a tree that shrinking the underlying database
       file  is desirable, this can be accomplished by creating a
       new tree from a scan of the existing one.

       The following additional fields and flags may be  initial-
       ized in the DB_INFO structure before calling <EM>db</EM><STRONG>_</STRONG><EM>open</EM>, when
       using the btree access method:

       int (*bt_compare)(const DBT *, const DBT *);
            The <EM>bt</EM><STRONG>_</STRONG><EM>compare</EM> function is the key  comparison  func-
            tion.  It must return an integer less than, equal to,
            or greater than zero if the  first  key  argument  is
            considered to be respectively less than, equal to, or
            greater than the second key argument.  The same  com-
            parison  function  must be used on a given tree every
            time it is opened.  If <EM>bt</EM><STRONG>_</STRONG><EM>compare</EM> is NULL,  the  keys
            are  compared  lexically, with shorter keys collating
            before longer keys.

       int bt_minkey;
            The minimum number of keys that will be stored on any
            first  key  argument.  If the keys are equal, the key
            length should be returned.

            This is used to compress the keys stored on the btree
            internal  pages.   The  usefulness  of  this  is data
            dependent, but in some data sets can produce signifi-
            cantly  reduced  tree  sizes  and  search  times.  If
            <EM>bt</EM><STRONG>_</STRONG><EM>prefix</EM> is NULL,  and  no  comparison  function  is
            specified,  a  default lexical comparison function is
            used.  If <EM>bt</EM><STRONG>_</STRONG><EM>prefix</EM> is NULL and a comparison function
            is specified, no prefix comparison is done.

       unsigned long flags;
            The  following  additional  flags may be specified by
            <STRONG>or</STRONG>'ing together one or more of the following values:

            DB_DUP
                 Permit duplicate keys in the tree,  i.e.  inser-
                 tion  when  the  key  of the key/data pair being
                 inserted already exists in the tree will be suc-
                 cessful.  The ordering of duplicates in the tree
                 is determined by the order of insertion,  unless
                 the  ordering is otherwise specified by use of a
                 cursor (see <STRONG><A HREF="db_cursor.html">db_cursor(3)</A></STRONG> for more  information.)
                 It  is  an  error  to  specify  both  DB_DUP and
                 DB_RECNUM.

            DB_RECNUM
                 Support retrieval from btrees using record  num-
                 bers.     For    more   information,   see   the
                 DB_SET_RECNO  flag  to  the   <EM>DB-&gt;get</EM>   function
                 (below),  and  the  cursor  <EM>c</EM><STRONG>_</STRONG><EM>get</EM>  function  (in
                 <STRONG><A HREF="db_cursor.html">db_cursor(3)</A></STRONG>).

                 Logical record numbers in btrees are mutable  in
                 the  face  of record insertion or deletion.  See
                 the DB_RENUMBER flag in the RECNO section  below
                 for further discussion.

                 Maintaining  record counts within a btree intro-
                 duces a serious point of contention, namely  the
                 page  locations  where  the  record  counts  are
                 stored.  In addition, the entire  tree  must  be
                 locked  during  both  insertions  and deletions,
                 effectively single-threading the tree for  those
                 operations.   Specifying DB_RECNUM can result in
                 serious performance degradation for some  appli-
                 cations and data sets.


                 It  is  an  error  to  specify  both  DB_DUP and
                 DB_RECNUM.


</PRE>
<H2>HASH</H2><PRE>
            approximation  of the number of keys allowed to accu-
            mulate in any one bucket, determining when  the  hash
            table  grows  or  shrinks.   The  default value is 0,
            indicating that the  fill  factor  will  be  selected
            dynamically as pages are filled.

       u_int32_t (*h_hash)(const void *, u_int32_t);
            The  <EM>h</EM><STRONG>_</STRONG><EM>hash</EM> field is a user defined hash function; if
            <EM>h</EM><STRONG>_</STRONG><EM>hash</EM> is NULL, a  default  hash  function  is  used.
            Since  no  hash function performs equally well on all
            possible data, the user may find  that  the  built-in
            hash  function performs poorly with a particular data
            set.  User  specified  hash  functions  must  take  a
            pointer  to  a  byte string and a length as arguments
            and return a u_int32_t value.

            If a  hash  function  is  specified,  <EM>hash</EM><STRONG>_</STRONG><EM>open</EM>  will
            attempt  to  determine if the hash function specified
            is the same as the one with which  the  database  was
            created,  and will fail if it detects that it is not.

       unsigned int h_nelem;
            An estimate of the final size of the hash table.   If
            not  set  or  set  too  low,  hash tables will expand
            gracefully as keys are  entered,  although  a  slight
            performance  degradation may be noticed.  The default
            value is 1.

       unsigned long flags;
            The following additional flags may  be  specified  by
            <STRONG>or</STRONG>'ing together one or more of the following values:

            DB_DUP
                 Permit  duplicate  keys in the tree, i.e. inser-
                 tion when the key of  the  key/data  pair  being
                 inserted already exists in the tree will be suc-
                 cessful.  The ordering of duplicates in the tree
                 is  determined by the order of insertion, unless
                 the ordering is otherwise specified by use of  a
                 cursor  (see <STRONG><A HREF="db_cursor.html">db_cursor(3)</A></STRONG> for more information.)


</PRE>
<H2>RECNO</H2><PRE>
       The recno access method provides  support  for  fixed  and
       variable  length records, optionally backed by a flat text
       (byte  stream)  file.   Both  fixed  and  variable  length
       records are accessed by their logical record number.

       It is valid to create a record whose record number is more
       than one greater than the last  record  currently  in  the
       database.   For  example, the creation of record number 8,
       when records 6 and 7 do not yet exist, is  not  an  error.
       However,  any  attempt  to  retrieve  such  records (e.g.,
       records 6 and 7) will return DB_KEYEMPTY.

            delimiting  byte  used to mark the end of a record in
            the source file.  If the <EM>re</EM><STRONG>_</STRONG><EM>source</EM> file is  specified
            and the DB_DELIMITER flag is not set, &lt;newline&gt; char-
            acters (i.e. ``\n'', 0x0a) are interpreted as end-of-
            record markers.

       u_int32_t re_len;
            The length of a fixed-length record.

       int re_pad;
            For  fixed length records, if the DB_PAD flag is set,
            the pad character for short records.  If  the  DB_PAD
            flag  is not set, &lt;space&gt; characters (i.e., 0x20) are
            used for padding.

       char *re_source;
            The purpose of the <EM>re</EM><STRONG>_</STRONG><EM>source</EM> field is to provide fast
            access  and  modification  to databases that are nor-
            mally stored as flat text files.

            If the <EM>re</EM><STRONG>_</STRONG><EM>source</EM> field is non-NULL, it  specifies  an
            underlying  flat  text  database file that is read to
            initialize a transient record number index.   In  the
            case of variable length records, the records are sep-
            arated by the  byte  value  <EM>re</EM><STRONG>_</STRONG><EM>delim</EM>.   For  example,
            standard UNIX byte stream files can be interpreted as
            a sequence of variable length  records  separated  by
            &lt;newline&gt; characters.

            In addition, when cached data would normally be writ-
            ten back to the underlying database file  (e.g.,  the
            <EM>close</EM>  or  <EM>sync</EM>  functions are called), the in-memory
            copy of the database will  be  written  back  to  the
            <EM>re</EM><STRONG>_</STRONG><EM>source</EM> file.

            By  default,  the backing source file is read lazily,
            i.e., records are not read from the file  until  they
            are  requested  by the application.  <STRONG>If</STRONG> <STRONG>multiple</STRONG> <STRONG>pro-</STRONG>
            <STRONG>cesses</STRONG> <STRONG>(not</STRONG> <STRONG>threads)</STRONG> <STRONG>are</STRONG> <STRONG>accessing</STRONG> <STRONG>a</STRONG>  <STRONG>recno</STRONG>  <STRONG>database</STRONG>
            <STRONG>concurrently</STRONG>   <STRONG>and</STRONG>   <STRONG>either</STRONG>   <STRONG>inserting</STRONG>  <STRONG>or</STRONG>  <STRONG>deleting</STRONG>
            <STRONG>records,</STRONG> <STRONG>the</STRONG> <STRONG>backing</STRONG> <STRONG>source</STRONG> <STRONG>file</STRONG> <STRONG>must</STRONG> <STRONG>be</STRONG> <STRONG>read</STRONG> <STRONG>in</STRONG>  <STRONG>its</STRONG>
            <STRONG>entirety</STRONG>  <STRONG>before</STRONG>  <STRONG>more</STRONG> <STRONG>than</STRONG> <STRONG>a</STRONG> <STRONG>single</STRONG> <STRONG>process</STRONG> <STRONG>accesses</STRONG>
            <STRONG>the</STRONG> <STRONG>database,</STRONG> <STRONG>and</STRONG> <STRONG>only</STRONG> <STRONG>that</STRONG>  <STRONG>process</STRONG>  <STRONG>should</STRONG>  <STRONG>specify</STRONG>
            <STRONG>the</STRONG>  <STRONG>backing</STRONG> <STRONG>source</STRONG> <STRONG>file</STRONG> <STRONG>as</STRONG> <STRONG>part</STRONG> <STRONG>of</STRONG> <STRONG>the</STRONG> <STRONG>db_open</STRONG> <STRONG>call.</STRONG>
            See the DB_SNAPSHOT flag below for more  information.

            <STRONG>Reading</STRONG> <STRONG>and</STRONG> <STRONG>writing</STRONG> <STRONG>the</STRONG> <STRONG>backing</STRONG> <STRONG>source</STRONG> <STRONG>file</STRONG> <STRONG>specified</STRONG>
            <STRONG>by</STRONG>  <STRONG>re_source</STRONG>  <STRONG>cannot</STRONG>  <STRONG>be</STRONG>  <STRONG>transactionally</STRONG>  <STRONG>protected</STRONG>
            <STRONG>because</STRONG>  <STRONG>it</STRONG>  <STRONG>involves</STRONG>  <STRONG>filesystem</STRONG> <STRONG>operations</STRONG> <STRONG>that</STRONG> <STRONG>are</STRONG>
            <STRONG>not</STRONG> <STRONG>part</STRONG> <STRONG>of</STRONG> <STRONG>the</STRONG> <STRONG>DB</STRONG> <STRONG>transaction</STRONG> <STRONG>methodology.</STRONG>  For this
            reason,  if  a temporary database is used to hold the
            records, i.e., a NULL was specified as the <EM>file</EM> argu-
            ment  to <EM>db</EM><STRONG>_</STRONG><EM>open</EM>, it is possible to lose the contents
            of the <EM>re</EM><STRONG>_</STRONG><EM>source</EM> file, e.g., if the system crashes at
            only  for DB applications, and that are either gener-
            ated on the fly by software tools, or modified  using
            a different mechanism, e.g., a text editor.

       unsigned long flags;
            The  following  additional  flags may be specified by
            <STRONG>or</STRONG>'ing together one or more of the following values:

            DB_DELIMITER
                 The <EM>re</EM><STRONG>_</STRONG><EM>delim</EM> field is set.

            DB_FIXEDLEN
                 The records are fixed-length,  not  byte  delim-
                 ited.   The  structure  element <EM>re</EM><STRONG>_</STRONG><EM>len</EM> specifies
                 the length of the record, and the structure ele-
                 ment <EM>re</EM><STRONG>_</STRONG><EM>pad</EM> is used as the pad character.

                 Any  records added to the database that are less
                 than <EM>re</EM><STRONG>_</STRONG><EM>len</EM> bytes long are automatically padded.
                 Any  attempt to insert records into the database
                 that are greater than  <EM>re</EM><STRONG>_</STRONG><EM>len</EM>  bytes  long  will
                 cause the call to fail immediately and return an
                 error.

            DB_PAD
                 The <EM>re</EM><STRONG>_</STRONG><EM>pad</EM> field is set.

            DB_RENUMBER
                 Specifying the DB_RENUMBER flag causes the logi-
                 cal  record numbers to be mutable, and change as
                 records  are  added  to  and  deleted  from  the
                 database.   For  example, the deletion of record
                 number 4 causes records numbered 5  and  greater
                 to be renumbered downward by 1.  If a cursor was
                 positioned to record number 4 before  the  dele-
                 tion, it will reference the new record number 4,
                 if any such record exists, after  the  deletion.
                 If a cursor was positioned after record number 4
                 before the deletion, it will be shifted downward
                 1  logical  record,  continuing to reference the
                 same record as it did before.

                 Using the <EM>c</EM><STRONG>_</STRONG><EM>put</EM> or <EM>put</EM> interfaces to create  new
                 records  will  cause  the  creation  of multiple
                 records if the record number is  more  than  one
                 greater than the largest record currently in the
                 database.  For example, creating record 28, when
                 record  25 was previously the last record in the
                 database, will create records 26 and 27 as  well
                 as  28.   Attempts to retrieve records that were
                 created in this manner will result in  an  error
                 return of DB_KEYEMPTY.

                 If  a  created  record  is not at the end of the
                 be largely  meaningless,  although  it  is  sup-
                 ported.
            DB_SNAPSHOT
                 This flag specifies that any specified <EM>re</EM><STRONG>_</STRONG><EM>source</EM>
                 file be read in its  entirety  when  <EM>db</EM><STRONG>_</STRONG><EM>open</EM>  is
                 called.   If  this  flag  is  not specified, the
                 <EM>re</EM><STRONG>_</STRONG><EM>source</EM> file may be read lazily.



</PRE>
<H2>DB OPERATIONS</H2><PRE>
       The DB structure returned by <EM>db</EM><STRONG>_</STRONG><EM>open</EM> describes a  database
       type,  and  includes a set of functions to perform various
       actions, as described  below.   Each  of  these  functions
       takes  a  pointer  to  a DB structure, and may take one or
       more DBT *'s and a flag value as well.  The fields of  the
       DB structure are as follows:

       DBTYPE type;
            The  type  of  the underlying access method (and file
            format).   Set  to  one  of  DB_BTREE,   DB_HASH   or
            DB_RECNO.   This  field  may be used to determine the
            type of the database after a return from <EM>db</EM><STRONG>_</STRONG><EM>open</EM> with
            the <EM>type</EM> argument set to DB_UNKNOWN.

       int (*close)(DB *db, int flags);
            A  pointer to a function to flush any cached informa-
            tion to disk, close any  open  cursors  (see  <EM>db</EM><STRONG>_</STRONG><EM>cur-</EM>
            <STRONG><A HREF="sor.html">sor(3)</A></STRONG>),  free any allocated resources, and close any
            underlying files.  Since key/data pairs are cached in
            memory,  failing  to  sync the file with the <EM>close</EM> or
            <EM>sync</EM> function may  result  in  inconsistent  or  lost
            information.

            The <EM>flags</EM> parameter must be set to 0 or the following
            value:

            DB_NOSYNC
                 Do not flush cached information to disk.

            The DB_NOSYNC flag is a dangerous option.  It  should
            only be set if the application is doing logging (with
            or without transactions)  so  that  the  database  is
            recoverable  after  a system or application crash, or
            if the database  is  always  generated  from  scratch
            after any system or application crash.

            <STRONG>It</STRONG>  <STRONG>is</STRONG>  <STRONG>important</STRONG>  <STRONG>to</STRONG> <STRONG>understand</STRONG> <STRONG>that</STRONG> <STRONG>flushing</STRONG> <STRONG>cached</STRONG>
            <STRONG>information</STRONG> <STRONG>to</STRONG> <STRONG>disk</STRONG>  <STRONG>only</STRONG>  <STRONG>minimizes</STRONG>  <STRONG>the</STRONG>  <STRONG>window</STRONG>  <STRONG>of</STRONG>
            <STRONG>opportunity</STRONG>  <STRONG>for</STRONG>  <STRONG>corrupted</STRONG> <STRONG>data.</STRONG>  While unlikely, it
            is possible for database corruption to  happen  if  a
            system or application crash occurs while writing data
            to the database.  To ensure that database  corruption
            never  occurs, applications must either: use transac-
            tions and logging with automatic recovery,  use  log-

       int (*cursor)(DB *db, DB_TXN *txnid, DBC **cursorp);
            A pointer to a function to create a cursor and copy a
            pointer  to it into the memory referenced by <EM>cursorp</EM>.

            A cursor is a structure used  to  provide  sequential
            access  through  a  database.  This interface and its
            associated functions replaces the functionality  pro-
            vided by the <EM>seq</EM> function in previous releases of the
            DB library.


            If the file is being accessed under transaction  pro-
            tection,  the  <EM>txnid</EM>  parameter  is  a transaction ID
            returned from <EM>txn</EM><STRONG>_</STRONG><EM>begin</EM>, otherwise, NULL.  If  trans-
            action  protection is enabled, cursors must be opened
            and closed within the context of a  transaction,  and
            the <EM>txnid</EM> parameter specifies the transaction context
            in which the cursor may be  used.   See  <STRONG><A HREF="db_cursor.html">db_cursor(3)</A></STRONG>
            for more information.

            The  <EM>cursor</EM>  function  returns  the value of <EM>errno</EM> on
            failure and 0 on success.

       int (*del)(DB *db, DB_TXN *txnid, DBT *key, int flags);
            A pointer to a function to remove key/data pairs from
            the  database.  The key/data pair associated with the
            specified <EM>key</EM> is discarded from the database.  In the
            presence of duplicate key values, all records associ-
            ated with the designated key will be discarded.

            If the file is being accessed under transaction  pro-
            tection,  the  <EM>txnid</EM>  parameter  is  a transaction ID
            returned from <EM>txn</EM><STRONG>_</STRONG><EM>begin</EM>, otherwise, NULL.

            The <EM>flags</EM> parameter is currently unused, and must  be
            set to 0.

            The  <EM>del</EM> function returns the value of <EM>errno</EM> on fail-
            ure, 0 on success, and DB_NOTFOUND if  the  specified
            <EM>key</EM> did not exist in the file.

       int (*fd)(DB *db, int *fdp);
            A pointer to a function that copies a file descriptor
            representative of the underlying  database  into  the
            memory  referenced  by <EM>fdp</EM>.  A file descriptor refer-
            encing the same file will be  returned  to  all  pro-
            cesses that call <EM>db</EM><STRONG>_</STRONG><EM>open</EM> with the same <EM>file</EM> argument.
            This file descriptor may be safely used as  an  argu-
            ment  to the <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG> and <STRONG><A HREF="flock.html">flock(2)</A></STRONG> locking functions.
            The file descriptor  is  not  necessarily  associated
            with  any  of the underlying files used by the access
            method.

            The <EM>fd</EM> function only supports a  coarse-grained  form

            In the presence of duplicate  key  values,  <EM>get</EM>  will
            return  the  first  data item for the designated key.
            Duplicates are sorted by insert  order  except  where
            this order has been overwritten by cursor operations.
            <STRONG>Retrieval</STRONG> <STRONG>of</STRONG> <STRONG>duplicates</STRONG> <STRONG>requires</STRONG> <STRONG>the</STRONG>  <STRONG>use</STRONG>  <STRONG>of</STRONG>  <STRONG>cursor</STRONG>
            <STRONG>operations.</STRONG>  See <STRONG><A HREF="db_cursor.html">db_cursor(3)</A></STRONG> for details.

            If  the file is being accessed under transaction pro-
            tection, the <EM>txnid</EM>  parameter  is  a  transaction  ID
            returned from <EM>txn</EM><STRONG>_</STRONG><EM>begin</EM>, otherwise, NULL.

            The <EM>flags</EM> parameter must be set to 0 or the following
            value:

            DB_SET_RECNO
                 Retrieve the specified  numbered  key/data  pair
                 from  a database.  Upon return, both the <EM>key</EM> and
                 <EM>data</EM> items will have been filled  in,  not  just
                 the  data  item as is done for all other uses of
                 the <EM>get</EM> function.

                 The <EM>data</EM> field of the specified <EM>key</EM>  must  be  a
                 pointer  to  a  memory  location  from  which  a
                 <EM>db</EM><STRONG>_</STRONG><EM>recno</EM><STRONG>_</STRONG><EM>t</EM>  may  be  read,   as   described   in
                 <STRONG><A HREF="db_dbt.html">db_dbt(3)</A></STRONG>.  This memory location will be read to
                 determine the record to be retrieved.

                 For DB_SET_RECNO to be specified, the underlying
                 database  must be of type btree and it must have
                 been  created  with  the  DB_RECNUM  flag   (see
                 <STRONG><A HREF="db_open.html">db_open(3)</A></STRONG>).

            If the database is a recno database and the requested
            key exists, but was never explicitly created  by  the
            application  or  was  later deleted, the <EM>get</EM> function
            returns DB_KEYEMPTY.  Otherwise, if the requested key
            isn't  in  the  database,  the  <EM>get</EM>  function returns
            DB_NOTFOUND.  Otherwise, the <EM>get</EM> function returns the
            value of <EM>errno</EM> on failure and 0 on success.

       int (*put)(DB *db, DB_TXN *txnid,
                 DBT *key, DBT *data, int flags);
            A  pointer  to  a function to store key/data pairs in
            the database.  If the database  supports  duplicates,
            the  <EM>put</EM>  function adds the new data value at the end
            of the duplicate set.

            If the file is being accessed under transaction  pro-
            tection,  the  <EM>txnid</EM>  parameter  is  a transaction ID
            returned from <EM>txn</EM><STRONG>_</STRONG><EM>begin</EM>, otherwise, NULL.

            The flags value is specified by <STRONG>or</STRONG>'ing  together  one
            or more of the following values:
            The default behavior of the <EM>put</EM> function is to  enter
            the  new  key/data  pair,  replacing  any  previously
            existing key if duplicates are disallowed, or to  add
            a duplicate entry if duplicates are allowed.  Even if
            the designated database allows duplicates, a call  to
            <EM>put</EM> with the DB_NOOVERWRITE flag set will fail if the
            key already exists in the database.

            The <EM>put</EM> function returns the value of <EM>errno</EM> on  fail-
            ure,  0 on success, and DB_KEYEXIST if the DB_NOOVER-
            WRITE <EM>flag</EM> was set and the key already exists in  the
            file.

       int (*sync)(DB *db, int flags);
            A  pointer to a function to flush any cached informa-
            tion to disk.  If the database is in memory only, the
            <EM>sync</EM>  function has no effect and will always succeed.

            The <EM>flags</EM> parameter is currently unused, and must  be
            set to 0.


            See  the  <EM>close</EM> function description above for a dis-
            cussion of DB and cached data.

            The <EM>sync</EM> function returns the value of <EM>errno</EM> on fail-
            ure and 0 on success.

       int (*stat)(DB *db, void *sp,
                 void *(*db_malloc)(size_t), int flags);
            A  pointer  to  a  function  to  create a statistical
            structure and copy a pointer to it  into  user-speci-
            fied  memory  locations.  Specifically, if <EM>sp</EM> is non-
            NULL, a pointer to the statistics  for  the  database
            are copied into the memory location it references.

            Statistical  structures are created in allocated mem-
            ory.  If <EM>db</EM><STRONG>_</STRONG><EM>malloc</EM> is non-NULL, it is called to allo-
            cate the memory, otherwise, the library function <EM>mal-</EM>
            <STRONG><A HREF="loc.html">loc(3)</A></STRONG> is used.  The function  <EM>db</EM><STRONG>_</STRONG><EM>malloc</EM>  must  match
            the calling conventions of the <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG> library rou-
            tine.  Regardless,  the  caller  is  responsible  for
            deallocating  the returned memory.  To deallocate the
            returned memory, free each returned  memory  pointer;
            pointers inside the memory do not need to be individ-
            ually freed.

            <STRONG>In</STRONG> <STRONG>the</STRONG> <STRONG>presence</STRONG>  <STRONG>of</STRONG>  <STRONG>multiple</STRONG>  <STRONG>threads</STRONG>  <STRONG>or</STRONG>  <STRONG>processes</STRONG>
            <STRONG>accessing</STRONG>  <STRONG>an</STRONG>  <STRONG>active</STRONG> <STRONG>database,</STRONG> <STRONG>the</STRONG> <STRONG>returned</STRONG> <STRONG>informa-</STRONG>
            <STRONG>tion</STRONG> <STRONG>may</STRONG> <STRONG>be</STRONG> <STRONG>out-of-date.</STRONG>

            <STRONG>This</STRONG> <STRONG>function</STRONG> <STRONG>may</STRONG> <STRONG>access</STRONG> <STRONG>all</STRONG>  <STRONG>of</STRONG>  <STRONG>the</STRONG>  <STRONG>pages</STRONG>  <STRONG>in</STRONG>  <STRONG>the</STRONG>
            <STRONG>database,</STRONG>  <STRONG>and</STRONG>  <STRONG>therefore</STRONG>  <STRONG>may</STRONG> <STRONG>incur</STRONG> <STRONG>a</STRONG> <STRONG>severe</STRONG> <STRONG>perfor-</STRONG>
            <STRONG>mance</STRONG> <STRONG>penalty</STRONG> <STRONG>and</STRONG> <STRONG>have</STRONG> <STRONG>obvious</STRONG>  <STRONG>negative</STRONG>  <STRONG>effects</STRONG>  <STRONG>on</STRONG>
                 database   without   incurring   a   performance
                 penalty.    It   is  only  available  for  recno
                 databases, or btree databases where the underly-
                 ing  database  was  created  with  the DB_RECNUM
                 flag.

            The <EM>stat</EM> function returns the value of <EM>errno</EM> on fail-
            ure and 0 on success.

            In  the  case  of  a  btree  or  recno  database, the
            statistics  are  stored  in  a  structure   of   type
            DB_BTREE_STAT  (typedef'd  in &lt;db.h&gt;).  The following
            fields will be filled in:

            u_int32_t bt_magic;
                 Magic number that identifies the file as a btree
                 file.
            u_int32_t bt_version;
                 The version of the btree file type.
            u_int32_t bt_flags;
                 Permanent   database  flags,  including  DB_DUP,
                 DB_FIXEDLEN, DB_RECNUM and DB_RENUMBER.
            u_int32_t bt_minkey;
                 The <EM>bt</EM><STRONG>_</STRONG><EM>minkey</EM> value specified to <STRONG><A HREF="db_open.html">db_open(3)</A></STRONG>,  if
                 any.
            u_int32_t bt_re_len;
                 The  <EM>re</EM><STRONG>_</STRONG><EM>len</EM>  value  specified  to <STRONG><A HREF="db_open.html">db_open(3)</A></STRONG>, if
                 any.
            u_int32_t bt_re_pad;
                 The <EM>re</EM><STRONG>_</STRONG><EM>pad</EM> value  specified  to  <STRONG><A HREF="db_open.html">db_open(3)</A></STRONG>,  if
                 any.
            u_int32_t bt_pagesize;
                 Underlying tree page size.
            u_int32_t bt_levels;
                 Number of levels in the tree.
            u_int32_t bt_nrecs;
                 Number  of  data  items in the tree (since there
                 may be multiple data items per key, this  number
                 may not be the same as the number of keys).
            u_int32_t bt_int_pg;
                 Number of tree internal pages.
            u_int32_t bt_leaf_pg;
                 Number of tree leaf pages.
            u_int32_t bt_dup_pg;
                 Number of tree duplicate pages.
            u_int32_t bt_over_pg;
                 Number of tree overflow pages.
            u_int32_t bt_free;
                 Number of pages on the free list.
            u_int32_t bt_freed;
                 Number of pages made available for reuse because
                 they were emptied.
            u_int32_t bt_int_pgfree;
                 Number of bytes free in tree internal pages.
                 Number of root page splits.
            u_int32_t bt_fastsplit;
                 Number  of  fast  splits.   When sorted keys are
                 added to the database, the DB btree  implementa-
                 tion  will  split  left or right to increase the
                 page-fill factor.  This number is a  measure  of
                 how  often it was possible to make such a split.
            u_int32_t bt_added;
                 Number of keys added.
            u_int32_t bt_deleted;
                 Number of keys deleted.
            u_int32_t bt_get;
                 Number of keys  retrieved.   (Note,  this  value
                 will  not  reflect  any  keys retrieved when the
                 database was open for read-only access, as there
                 is  no  permanent location to store the informa-
                 tion in this case.)
            u_int32_t bt_cache_hit;
                 Number of hits in tree fast-insert  code.   When
                 sorted  keys  are  added to the database, the DB
                 btree implementation will check  the  last  page
                 where  an  insert  occurred  before doing a full
                 lookup.  This number is a measure of  how  often
                 the lookup was successful.
            u_int32_t bt_cache_miss;
                 Number  of misses in tree fast-insert code.  See
                 the description of bt_cache_hit; this number  is
                 a measure of how often the lookup failed.


</PRE>
<H2>ENVIRONMENT VARIABLES</H2><PRE>
       The  following  environment variables affect the execution
       of <EM>db</EM><STRONG>_</STRONG><EM>open</EM>:

       DB_HOME
            If the <EM>dbenv</EM>  argument  to  <EM>db</EM><STRONG>_</STRONG><EM>open</EM>  was  initialized
            using  <EM>db</EM><STRONG>_</STRONG><EM>appinit</EM>,  the  environment variable DB_HOME
            may be used as the path of the database home for  the
            interpretation  of  the  <EM>dir</EM>  argument to <EM>db</EM><STRONG>_</STRONG><EM>open</EM>, as
            described in <STRONG><A HREF="db_appinit.html">db_appinit(3)</A></STRONG>.  Specifically, <EM>db</EM><STRONG>_</STRONG><EM>open</EM> is
            affected   by   the  configuration  string  value  of
            DB_DATA_DIR.


</PRE>
<H2>EXAMPLES</H2><PRE>
       Applications that create short-lived  databases  that  are
       discarded  or  recreated  when  the  system  fails and are
       unconcerned with concurrent access and loss of data due to
       catastrophic  failure,  may  wish to use the <EM>db</EM><STRONG>_</STRONG><EM>open</EM> func-
       tionality without other parts of  the  DB  library.   Such
       applications  will  only  be  concerned with the DB access
       methods.  The DB access methods will use the  memory  pool
       subsystem,  but the application is unlikely to be aware of
       this.    See    the    files    <EM>example/ex</EM><STRONG>_</STRONG><EM>access.c</EM>    and
       <EM>example/ex</EM><STRONG>_</STRONG><EM>btrec.c</EM>  in  the  DB  source distribution for C
       language code examples of how such applications might  use
       <STRONG><A HREF="munmap.html">munmap(2)</A></STRONG>, <STRONG><A HREF="open.html">open(2)</A></STRONG>, <STRONG><A HREF="read.html">read(2)</A></STRONG>, <STRONG><A HREF="realloc.html">realloc(3)</A></STRONG>, <STRONG><A HREF="sigfillset.html">sigfillset(3)</A></STRONG>,
       <STRONG><A HREF="sigprocmask.html">sigprocmask(2)</A></STRONG>, <STRONG><A HREF="stat.html">stat(2)</A></STRONG>, <STRONG><A HREF="strcpy.html">strcpy(3)</A></STRONG>, <STRONG><A HREF="strdup.html">strdup(3)</A></STRONG>,
       <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>, <STRONG><A HREF="strlen.html">strlen(3)</A></STRONG>, <STRONG><A HREF="time.html">time(3)</A></STRONG>, and <STRONG><A HREF="unlink.html">unlink(2)</A></STRONG>.

       In addition, the <EM>db</EM><STRONG>_</STRONG><EM>open</EM> function may fail and return  <EM>er-</EM>
       <EM>rno</EM> for the following conditions:

       [EAGAIN]
            A lock was unavailable.

       [EINVAL]
            An  invalid  flag  value  or  parameter was specified
            (e.g., unknown database type, page size,  hash  func-
            tion,  recno pad byte, byte order) or a flag value or
            parameter that is incompatible with the current  <EM>file</EM>
            specification.

            The  DB_THREAD  flag  was specified and spinlocks are
            not implemented for this architecture.

            There is a mismatch between  the  version  number  of
            <EM>file</EM> and the software.

            A  <EM>re</EM><STRONG>_</STRONG><EM>source</EM>  file  was  specified  with  either  the
            DB_THREAD flag or a non-NULL  <EM>tx</EM><STRONG>_</STRONG><EM>info</EM>  field  in  the
            DB_ENV argument to db_open.

       [ENOENT]
            A non-existent <EM>re</EM><STRONG>_</STRONG><EM>source</EM> file was specified.

       [EPERM]
            Database  corruption  was  detected.   All subsequent
            database calls (other  than  <EM>DB-&gt;close</EM>)  will  return
            EPERM.

       The  <EM>DB-&gt;close</EM>  function may fail and return <EM>errno</EM> for any
       of the errors specified for the following DB  and  library
       functions: DB-&gt;<STRONG><A HREF="sync.html">sync(3)</A></STRONG>, <STRONG><A HREF="calloc.html">calloc(3)</A></STRONG>, <STRONG><A HREF="close.html">close(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>,
       <STRONG><A HREF="lock_get.html">lock_get(3)</A></STRONG>, <STRONG><A HREF="lock_put.html">lock_put(3)</A></STRONG>, <STRONG><A HREF="lock_vec.html">lock_vec(3)</A></STRONG>, <STRONG><A HREF="log_put.html">log_put(3)</A></STRONG>,
       <STRONG><A HREF="log_unregister.html">log_unregister(3)</A></STRONG>, <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG>, <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>, <STRONG><A HREF="memmove.html">memmove(3)</A></STRONG>,
       <STRONG><A HREF="memp_close.html">memp_close(3)</A></STRONG>, <STRONG><A HREF="memp_fclose.html">memp_fclose(3)</A></STRONG>, <STRONG><A HREF="memp_fget.html">memp_fget(3)</A></STRONG>, <STRONG><A HREF="memp_fput.html">memp_fput(3)</A></STRONG>,
       <STRONG><A HREF="memp_fset.html">memp_fset(3)</A></STRONG>, <STRONG><A HREF="memp_fsync.html">memp_fsync(3)</A></STRONG>, <STRONG><A HREF="memset.html">memset(3)</A></STRONG>, <STRONG><A HREF="munmap.html">munmap(2)</A></STRONG>,
       <STRONG><A HREF="realloc.html">realloc(3)</A></STRONG>, and <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>.

       The <EM>DB-&gt;cursor</EM> function may fail and return <EM>errno</EM> for  any
       of  the  errors specified for the following DB and library
       functions: <STRONG><A HREF="calloc.html">calloc(3)</A></STRONG>.

       In addition, the <EM>DB-&gt;cursor</EM> function may fail  and  return
       <EM>errno</EM> for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.


       In  addition, the <EM>DB-&gt;del</EM> function may fail and return <EM>er-</EM>
       <EM>rno</EM> for the following conditions:

       [EAGAIN]
            A lock was unavailable.

       [EINVAL]
            An invalid flag value or parameter was specified.

       [EPERM]
            Database corruption  was  detected.   All  subsequent
            database  calls  (other  than  <EM>DB-&gt;close</EM>) will return
            EPERM.

       In addition, the <EM>DB-&gt;fd</EM> function may fail and return <EM>errno</EM>
       for the following conditions:

       [ENOENT]
            The  <EM>DB-&gt;fd</EM>  function  was  called  for  an in-memory
            database, or no underlying file has yet been created.

       [EPERM]
            Database  corruption  was  detected.   All subsequent
            database calls (other  than  <EM>DB-&gt;close</EM>)  will  return
            EPERM.

       The  <EM>DB-&gt;get</EM> function may fail and return <EM>errno</EM> for any of
       the errors specified for  the  following  DB  and  library
       functions: DBcursor-&gt;<STRONG><A HREF="c_get.html">c_get(3)</A></STRONG>, <STRONG><A HREF="calloc.html">calloc(3)</A></STRONG>, <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>,
       <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="lock_get.html">lock_get(3)</A></STRONG>, <STRONG><A HREF="lock_id.html">lock_id(3)</A></STRONG>, <STRONG><A HREF="lock_put.html">lock_put(3)</A></STRONG>,
       <STRONG><A HREF="lock_vec.html">lock_vec(3)</A></STRONG>, <STRONG><A HREF="log_put.html">log_put(3)</A></STRONG>, <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG>, <STRONG><A HREF="memcmp.html">memcmp(3)</A></STRONG>, <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>,
       <STRONG><A HREF="memmove.html">memmove(3)</A></STRONG>, <STRONG><A HREF="memp_fget.html">memp_fget(3)</A></STRONG>, <STRONG><A HREF="memp_fput.html">memp_fput(3)</A></STRONG>, <STRONG><A HREF="memp_fset.html">memp_fset(3)</A></STRONG>,
       <STRONG><A HREF="memset.html">memset(3)</A></STRONG>, <STRONG><A HREF="realloc.html">realloc(3)</A></STRONG>, and <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>.

       In  addition, the <EM>DB-&gt;get</EM> function may fail and return <EM>er-</EM>
       <EM>rno</EM> for the following conditions:

       [EAGAIN]
            A lock was unavailable.

       [EINVAL]
            An invalid flag value or parameter was specified.

            The DB_THREAD flag was specified  to  the  <STRONG><A HREF="db_open.html">db_open(3)</A></STRONG>
            function    and    neither   the   DB_DBT_MALLOC   or
            DB_DBT_USERMEM flags were set in the DBT.

            A record number of 0 was specified.

       [EPERM]
            Database corruption  was  detected.   All  subsequent
            database  calls  (other  than  <EM>DB-&gt;close</EM>) will return
            EPERM.

       [EACCES]
            An attempt was made to modify a read-only database.

       [EAGAIN]
            A lock was unavailable.

       [EINVAL]
            An invalid flag value or parameter was specified.

            A record number of 0 was specified.

            An attempt was made to add a record to a fixed-length
            database that was too large to fit.

            An attempt was made to do a partial put.

       [EPERM]
            Database corruption  was  detected.   All  subsequent
            database  calls  (other  than  <EM>DB-&gt;close</EM>) will return
            EPERM.

       [ENOSPC]
            A btree exceeded the maximum btree depth (255).

       The <EM>DB-&gt;stat</EM> function may fail and return <EM>errno</EM> for any of
       the  errors  specified  for  the  following DB and library
       functions: <STRONG><A HREF="calloc.html">calloc(3)</A></STRONG>, <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="lock_get.html">lock_get(3)</A></STRONG>,
       <STRONG><A HREF="lock_id.html">lock_id(3)</A></STRONG>, <STRONG><A HREF="lock_put.html">lock_put(3)</A></STRONG>, <STRONG><A HREF="lock_vec.html">lock_vec(3)</A></STRONG>, <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG>,
       <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>, <STRONG><A HREF="memp_fget.html">memp_fget(3)</A></STRONG>, <STRONG><A HREF="memp_fput.html">memp_fput(3)</A></STRONG>, and <STRONG><A HREF="memset.html">memset(3)</A></STRONG>.

       The <EM>DB-&gt;sync</EM> function may fail and return <EM>errno</EM> for any of
       the  errors  specified  for  the  following DB and library
       functions: DB-&gt;<STRONG><A HREF="get.html">get(3)</A></STRONG>, DB-&gt;<STRONG><A HREF="sync.html">sync(3)</A></STRONG>, <STRONG><A HREF="calloc.html">calloc(3)</A></STRONG>, <STRONG><A HREF="close.html">close(2)</A></STRONG>,
       <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="lock_get.html">lock_get(3)</A></STRONG>, <STRONG><A HREF="lock_id.html">lock_id(3)</A></STRONG>, <STRONG><A HREF="lock_put.html">lock_put(3)</A></STRONG>,
       <STRONG><A HREF="lock_vec.html">lock_vec(3)</A></STRONG>, <STRONG><A HREF="log_put.html">log_put(3)</A></STRONG>, <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG>, <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>, <STRONG><A HREF="memmove.html">memmove(3)</A></STRONG>,
       <STRONG><A HREF="memp_fget.html">memp_fget(3)</A></STRONG>, <STRONG><A HREF="memp_fput.html">memp_fput(3)</A></STRONG>, <STRONG><A HREF="memp_fset.html">memp_fset(3)</A></STRONG>, <STRONG><A HREF="memp_fsync.html">memp_fsync(3)</A></STRONG>,
       <STRONG><A HREF="memset.html">memset(3)</A></STRONG>, <STRONG><A HREF="munmap.html">munmap(2)</A></STRONG>, <STRONG><A HREF="open.html">open(2)</A></STRONG>, <STRONG><A HREF="realloc.html">realloc(3)</A></STRONG>, <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>,
       <STRONG><A HREF="unlink.html">unlink(2)</A></STRONG>, and <STRONG><A HREF="write.html">write(2)</A></STRONG>.

       In addition, the <EM>DB-&gt;sync</EM> function may fail and return <EM>er-</EM>
       <EM>rno</EM> for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

       [EPERM]
            Database corruption  was  detected.   All  subsequent
            database  calls  (other  than  <EM>DB-&gt;close</EM>) will return
            EPERM.


</PRE>
<H2>SEE ALSO</H2><PRE>
       <EM>The</EM> <EM>Ubiquitous</EM> <EM>B-tree</EM>, Douglas Comer,  ACM  Comput.  Surv.
       11, 2 (June 1979), 121-138.

       <EM>Document</EM>  <EM>Processing</EM>  <EM>in</EM>  <EM>a</EM>  <EM>Relational</EM>  <EM>Database</EM>  <EM>System</EM>,
       Michael Stonebraker, Heidi Stettner,  Joseph  Kalash,  An-
       tonin Guttman, Nadene Lynn, Memorandum No. UCB/ERL M82/32,
       May 1982.
       <STRONG><A HREF="db_archive.html">db_archive(1)</A></STRONG>, <STRONG><A HREF="db_checkpoint.html">db_checkpoint(1)</A></STRONG>, <STRONG><A HREF="db_deadlock.html">db_deadlock(1)</A></STRONG>, <STRONG><A HREF="db_dump.html">db_dump(1)</A></STRONG>,
       <STRONG><A HREF="db_load.html">db_load(1)</A></STRONG>, <STRONG><A HREF="db_recover.html">db_recover(1)</A></STRONG>, <STRONG><A HREF="db_stat.html">db_stat(1)</A></STRONG>, <STRONG><A HREF="db_intro.html">db_intro(3)</A></STRONG>,
       <STRONG><A HREF="db_appinit.html">db_appinit(3)</A></STRONG>, <STRONG><A HREF="db_cursor.html">db_cursor(3)</A></STRONG>, <STRONG><A HREF="db_dbm.html">db_dbm(3)</A></STRONG>, <STRONG><A HREF="db_jump.html">db_jump(3)</A></STRONG>, <STRONG><A HREF="db_lock.html">db_lock(3)</A></STRONG>,
       <STRONG><A HREF="db_log.html">db_log(3)</A></STRONG>, <STRONG><A HREF="db_mpool.html">db_mpool(3)</A></STRONG>, <STRONG><A HREF="db_open.html">db_open(3)</A></STRONG>, <STRONG><A HREF="db_thread.html">db_thread(3)</A></STRONG>, <STRONG><A HREF="db_txn.html">db_txn(3)</A></STRONG>
</PRE>
</BODY>
</HTML>
