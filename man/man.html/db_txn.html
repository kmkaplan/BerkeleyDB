<HTML>
<HEAD>
<TITLE>db_txn</TITLE>
</HEAD>
<BODY>
<H1>db_txn</H1>
<HR>
<PRE>

</PRE>
<H2>NAME</H2><PRE>
       db_txn - DB transaction management


</PRE>
<H2>SYNOPSIS</H2><PRE>
       <STRONG>#include</STRONG> <STRONG>&lt;db.h&gt;</STRONG>

       <STRONG>int</STRONG>
       <STRONG>txn_open(const</STRONG> <STRONG>char</STRONG> <STRONG>*dir,</STRONG>
            <STRONG>int</STRONG> <STRONG>flags,</STRONG> <STRONG>int</STRONG> <STRONG>mode,</STRONG> <STRONG>DB_ENV</STRONG> <STRONG>*dbenv,</STRONG> <STRONG>DB_TXNMGR</STRONG> <STRONG>**regionp);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>txn_begin(DB_TXNMGR</STRONG> <STRONG>*txnp,</STRONG> <STRONG>DB_TXN</STRONG> <STRONG>*pid,</STRONG> <STRONG>DB_TXN</STRONG> <STRONG>**tid);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>txn_prepare(DB_TXN</STRONG> <STRONG>*tid);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>txn_commit(DB_TXN</STRONG> <STRONG>*tid);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>txn_abort(DB_TXN</STRONG> <STRONG>*tid);</STRONG>

       <STRONG>u_int32_t</STRONG>
       <STRONG>txn_id(DB_TXN</STRONG> <STRONG>*tid);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>txn_checkpoint(const</STRONG> <STRONG>DB_TXNMGR</STRONG> <STRONG>*txnp,</STRONG> <STRONG>int</STRONG> <STRONG>kbyte,</STRONG> <STRONG>int</STRONG> <STRONG>min);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>txn_close(DB_TXNMGR</STRONG> <STRONG>*txnp);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>txn_unlink(const</STRONG> <STRONG>char</STRONG> <STRONG>*dir,</STRONG> <STRONG>int</STRONG> <STRONG>force,</STRONG> <STRONG>DB_ENV</STRONG> <STRONG>*dbenv);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>txn_stat(DB_TXNMGR</STRONG> <STRONG>*txnp,</STRONG>
            <STRONG>DB_TXN_STAT</STRONG> <STRONG>**statp,</STRONG> <STRONG>void</STRONG> <STRONG>*(*db_malloc)(size_t));</STRONG>


</PRE>
<H2>DESCRIPTION</H2><PRE>
       The  DB  library  is  a family of groups of functions that
       provides a modular programming interface  to  transactions
       and  record-oriented  file  access.   The library includes
       support for transactions, locking, logging and  file  page
       caching,  as well as various indexed access methods.  Many
       of the functional groups  (e.g.,  the  file  page  caching
       functions)  are  useful  independent of the other DB func-
       tions, although  some  functional  groups  are  explicitly
       based  on  other functional groups (e.g., transactions and
       logging).  For a general description of  the  DB  package,
       see <STRONG><A HREF="db_intro.html">db_intro(3)</A></STRONG>.

       This  manual page describes the specific details of the DB
       transaction support.

       by the access methods) is that write-ahead logging is pro-
       vided by <STRONG><A HREF="db_log.html">db_log(3)</A></STRONG> to record both before- and  after-image
       logging.   Locking follows a two-phase protocol (i.e., all
       locks are released at transaction commit).

  <EM>txn</EM><STRONG>_</STRONG><EM>open</EM>
       The <EM>txn</EM><STRONG>_</STRONG><EM>open</EM> function copies a pointer, to the transaction
       region  identified  by  the <STRONG>directory</STRONG> <EM>dir</EM>, into the memory
       location referenced by <EM>regionp</EM>.

       If the <EM>dbenv</EM> argument to <EM>txn</EM><STRONG>_</STRONG><EM>open</EM>  was  initialized  using
       <EM>db</EM><STRONG>_</STRONG><EM>appinit</EM>,   <EM>dir</EM>   is   interpreted   as   described   by
       <STRONG><A HREF="db_appinit.html">db_appinit(3)</A></STRONG>.

       Otherwise, if <EM>dir</EM> is not NULL, it is interpreted  relative
       to  the  current working directory of the process.  If <EM>dir</EM>
       is NULL, the following environment variables  are  checked
       in  order:  ``TMPDIR'',  ``TEMP'', and ``TMP''.  If one of
       them is set, transaction region files are created relative
       to  the  directory it specifies.  If none of them are set,
       the first possible one of  the  following  directories  is
       used: <EM>/var/tmp</EM>, <EM>/usr/tmp</EM>, <EM>/temp</EM>, <EM>/tmp</EM>, <EM>C:/temp</EM> and <EM>C:/tmp</EM>.

       All files associated with the transaction region are  cre-
       ated in this directory.  This directory must already exist
       when <EM>is</EM> <EM>called.</EM>  If the transaction region already exists,
       the  process  must  have  permission to read and write the
       existing  files.   If  the  transaction  region  does  not
       already exist, it is optionally created and initialized.

       The  <EM>flags</EM>  and  <EM>mode</EM>  arguments specify how files will be
       opened and/or created when they don't already exist.   The
       flags value is specified by <STRONG>or</STRONG>'ing together one or more of
       the following values:

       DB_CREATE
            Create any underlying files, as  necessary.   If  the
            files  do not already exist and the DB_CREATE flag is
            not specified, the call will fail.

       DB_THREAD
            Cause the DB_TXNMGR handle returned by  the  <EM>txn</EM><STRONG>_</STRONG><EM>open</EM>
            function  to  be useable by multiple threads within a
            single address space, i.e., to be  ``free-threaded''.

       DB_TXN_NOSYNC
            On transaction commit, do not synchronously flush the
            log.  This means that transactions  exhibit  the  ACI
            (atomicity,  consistency  and  isolation) properties,
            but not D (durability), i.e., database integrity will
            be  maintained but it is possible that some number of
            the  most  recently  committed  transactions  may  be
            undone during recovery instead of being redone.

       The transaction subsystem is configured based on the <EM>dbenv</EM>
       argument to <EM>txn</EM><STRONG>_</STRONG><EM>open</EM>, which is a pointer to a structure of
       type  DB_ENV  (typedef'd  in &lt;db.h&gt;).  It is expected that
       applications will use a single  DB_ENV  structure  as  the
       argument  to  all of the subsystems in the DB package.  In
       order to ensure compatibility with future releases of  DB,
       all fields of the DB_ENV structure that are not explicitly
       set should be initialized to 0 before the first  time  the
       structure  is  used.   Do  this by declaring the structure
       external or static, or by calling the  C  library  routine
       <STRONG><A HREF="bzero.html">bzero(3)</A></STRONG> or <STRONG><A HREF="memset.html">memset(3)</A></STRONG>.

       The  fields  of  the DB_ENV structure used by <EM>txn</EM><STRONG>_</STRONG><EM>open</EM> are
       described below.  As references to  the  DB_ENV  structure
       may  be  maintained  by <EM>txn</EM><STRONG>_</STRONG><EM>open</EM>, it is necessary that the
       DB_ENV structure and memory it references be  valid  until
       the <EM>txn</EM><STRONG>_</STRONG><EM>close</EM> function is called.  If <EM>dbenv</EM> is NULL or any
       of its fields are set to 0, defaults appropriate  for  the
       system are used where possible.

       The  following  fields in the DB_ENV structure may be ini-
       tialized before calling <EM>txn</EM><STRONG>_</STRONG><EM>open</EM>:


       void *(*db_errcall)(char *db_errpfx, char *buffer);
       FILE *db_errfile;
       const char *db_errpfx;
       int db_verbose;
            The error fields of the DB_ENV  behave  as  described
            for <STRONG><A HREF="db_appinit.html">db_appinit(3)</A></STRONG>.

       DB_LOG *lg_info;
            The logging region that is being used for this trans-
            action environment.  The  <EM>lg</EM><STRONG>_</STRONG><EM>info</EM>  field  contains  a
            return  value from the function <EM>log</EM><STRONG>_</STRONG><EM>open</EM>.  <STRONG>Logging</STRONG> <STRONG>is</STRONG>
            <STRONG>required</STRONG> <STRONG>for</STRONG> <STRONG>transaction</STRONG> <STRONG>environments,</STRONG> <STRONG>and</STRONG> <STRONG>it</STRONG>  <STRONG>is</STRONG>  <STRONG>an</STRONG>
            <STRONG>error</STRONG> <STRONG>to</STRONG> <STRONG>not</STRONG> <STRONG>specify</STRONG> <STRONG>a</STRONG> <STRONG>logging</STRONG> <STRONG>region.</STRONG>

       DB_LOCKTAB *lk_info;
            The locking region that is being used for this trans-
            action environment.  The  <EM>lk</EM><STRONG>_</STRONG><EM>info</EM>  field  contains  a
            return value from the function <EM>lock</EM><STRONG>_</STRONG><EM>open</EM>.  If <EM>lk</EM><STRONG>_</STRONG><EM>info</EM>
            is NULL, no locking is done in this transaction envi-
            ronment.

       unsigned int tx_max;
            The  maximum number of simultaneous transactions that
            are supported.  This bounds the size of backing files
            and is used to derive limits for the size of the lock
            region and logfiles.  When there are more than <EM>tx</EM><STRONG>_</STRONG><EM>max</EM>
            concurrent transactions, calls to <EM>txn</EM><STRONG>_</STRONG><EM>begin</EM> may cause
            backing files to grow.  If <EM>tx</EM><STRONG>_</STRONG><EM>max</EM>  is  0,  a  default
            value is used.

            redo An integer value that is set to one of the  fol-
                 lowing values:

                 DB_TXN_BACKWARD_ROLL
                      The log is being read backward to determine
                      which transactions have been committed  and
                      which  transactions  were  not  (and should
                      therefore be aborted during recovery).

                 DB_TXN_FORWARD_ROLL
                      The log is being played forward, any trans-
                      action  ids  encountered that have not been
                      entered into the list  referenced  by  <EM>info</EM>
                      should be ignored.

                 DB_TXN_OPENFILES
                      The log is being read to open all the files
                      required to perform recovery.

                 DB_TXN_REDO
                      Redo the operation  described  by  the  log
                      record.

                 DB_TXN_UNDO
                      Undo  the  operation  described  by the log
                      record.

            info An opaque pointer used to reference the list  of
                 transaction IDs encountered during recovery.

            If  <EM>recover</EM>  is  NULL,  the  default  is that only DB
            access method operations are  transaction  protected,
            and the default recover function will be used.

       The  <EM>txn</EM><STRONG>_</STRONG><EM>open</EM> function returns the value of <EM>errno</EM> on fail-
       ure and 0 on success.

  <EM>txn</EM><STRONG>_</STRONG><EM>begin</EM>
       The <EM>txn</EM><STRONG>_</STRONG><EM>begin</EM> function creates a new  transaction  in  the
       designated  transaction  manager,  copying  a pointer to a
       DB_TXN that uniquely identifies it into the memory  refer-
       enced  by  <EM>tid</EM>.   If the <EM>pid</EM> argument is non-NULL, the new
       transaction is a nested transaction with  the  transaction
       indicated by <EM>pid</EM> as its parent.

       Transactions  may not span threads, i.e., each transaction
       must begin and end in the same thread, and  each  transac-
       tion may only be used by a single thread.

       The <EM>txn</EM><STRONG>_</STRONG><EM>begin</EM> function returns the value of <EM>errno</EM> on fail-
       ure and 0 on success.

  <EM>txn</EM><STRONG>_</STRONG><EM>prepare</EM>
       The <EM>txn</EM><STRONG>_</STRONG><EM>prepare</EM> function initiates the beginning of a  two

  <EM>txn</EM><STRONG>_</STRONG><EM>commit</EM>
       The <EM>txn</EM><STRONG>_</STRONG><EM>commit</EM> function ends the transaction specified  by
       the  <EM>tid</EM>  argument.  If DB_TXN_NOSYNC was not specified, a
       commit log record is written and flushed to disk,  as  are
       all previously written log records.  If the transaction is
       nested, its locks are acquired by the parent  transaction,
       otherwise  its  locks are released.  Any applications that
       require strict two-phase  locking  must  not  release  any
       locks  explicitly,  leaving  them  all  to  be released by
       <EM>txn</EM><STRONG>_</STRONG><EM>commit</EM>.

       The <EM>txn</EM><STRONG>_</STRONG><EM>commit</EM> function returns  the  value  of  <EM>errno</EM>  on
       failure and 0 on success.

  <EM>txn</EM><STRONG>_</STRONG><EM>abort</EM>
       The  <EM>txn</EM><STRONG>_</STRONG><EM>abort</EM>  function causes an abnormal termination of
       the transaction.  The log is played backwards and any nec-
       essary  recovery  operations  are  initiated  through  the
       <EM>recover</EM> function specified to <EM>txn</EM><STRONG>_</STRONG><EM>open</EM>.  After recovery is
       completed,  all locks held by the transaction are acquired
       by the parent transaction in the case of a nested transac-
       tion  or released in the case of a non-nested transaction.
       As is the case for <EM>txn</EM><STRONG>_</STRONG><EM>commit</EM>, applications  that  require
       strict two phase locking should not explicitly release any
       locks.

       The <EM>txn</EM><STRONG>_</STRONG><EM>abort</EM> function returns the value of <EM>errno</EM> on fail-
       ure and 0 on success.

  <EM>txn</EM><STRONG>_</STRONG><EM>id</EM>
       The  <EM>txn</EM><STRONG>_</STRONG><EM>id</EM>  function  returns  the  unique transaction id
       associated with the specified transaction.  Locking  calls
       made  on  behalf  of this transaction should use the value
       returned from  <EM>txn</EM><STRONG>_</STRONG><EM>id</EM>  as  the  locker  parameter  to  the
       <EM>lock</EM><STRONG>_</STRONG><EM>get</EM> or <EM>lock</EM><STRONG>_</STRONG><EM>vec</EM> calls.

  <EM>txn</EM><STRONG>_</STRONG><EM>close</EM>
       The  <EM>txn</EM><STRONG>_</STRONG><EM>close</EM> function detaches a process from the trans-
       action environment specified  by  the  DB_TXNMGR  pointer.
       All   mapped   regions  are  unmapped  and  any  allocated
       resources are freed.   Any  uncommitted  transactions  are
       aborted.

       In  addition, if the <EM>dir</EM> argument to <EM>txn</EM><STRONG>_</STRONG><EM>open</EM> was NULL and
       <EM>dbenv</EM> was not initialized using <EM>db</EM><STRONG>_</STRONG><EM>appinit</EM>, all files cre-
       ated  for  this  shared  region  will  be  removed,  as if
       <EM>txn</EM><STRONG>_</STRONG><EM>unlink</EM> were called.

       When multiple threads are using the DB_TXNMGR handle  con-
       currently,  only  a  single  thread may call the <EM>txn</EM><STRONG>_</STRONG><EM>close</EM>
       function.

       The <EM>txn</EM><STRONG>_</STRONG><EM>close</EM> function returns the value of <EM>errno</EM> on fail-
       transaction region files regardless of any processes still
       using the transaction region.

       The result of attempting to forcibly  destroy  the  region
       when  a  process has the region open is unspecified.  Pro-
       cesses using a shared memory region maintain an open  file
       descriptor  for  it.   On UNIX systems, the region removal
       should succeed and processes that have already joined  the
       region  should  continue  to  run  in  the  region without
       change, however processes attempting to join the  transac-
       tion  region  will  either fail or attempt to create a new
       region.  On other systems, e.g., WNT, where the  <STRONG><A HREF="unlink.html">unlink(2)</A></STRONG>
       system  call  will  fail  if  any process has an open file
       descriptor for the file, the region removal will fail.

       In the case of catastrophic or  system  failure,  database
       recovery  must  be  performed  (see  <STRONG><A HREF="db_recovery.html">db_recovery(1)</A></STRONG> or the
       DB_RECOVER flags  to  <STRONG><A HREF="db_appinit.html">db_appinit(3)</A></STRONG>).   Alternatively,  if
       recovery  is  not  required  because  no database state is
       maintained across failures, it is possible to clean  up  a
       transaction  region  by  removing  all of the files in the
       directory specified to the <EM>txn</EM><STRONG>_</STRONG><EM>open</EM> function, as  transac-
       tion region files are never created in any directory other
       than the one specified to <EM>txn</EM><STRONG>_</STRONG><EM>open</EM>.  Note,  however,  that
       this  has  the  potential  to  remove files created by the
       other DB subsystems in this database environment.

       The <EM>txn</EM><STRONG>_</STRONG><EM>unlink</EM> function returns  the  value  of  <EM>errno</EM>  on
       failure and 0 on success.

  <EM>txn</EM><STRONG>_</STRONG><EM>checkpoint</EM>
       The  <EM>txn</EM><STRONG>_</STRONG><EM>checkpoint</EM>  function  syncs the underlying memory
       pool, writes a checkpoint  record  to  the  log  and  then
       flushes the log.

       If either <EM>kbyte</EM> or <EM>min</EM> is non-zero, the checkpoint is only
       done if more than <EM>min</EM> minutes have passed since  the  last
       checkpoint,  or  if  more than <EM>kbyte</EM> kilobytes of log data
       have been written since the last checkpoint.

       The <EM>txn</EM><STRONG>_</STRONG><EM>checkpoint</EM> function returns the value of <EM>errno</EM>  on
       failure,  0  on  success,  and DB_INCOMPLETE if there were
       pages that needed to be written but that <STRONG><A HREF="memp_sync.html">memp_sync(3)</A></STRONG>  was
       unable to write immediately.  In this case, the <EM>txn</EM><STRONG>_</STRONG><EM>check-</EM>
       <EM>point</EM> call should be retried.

       The <EM>txn</EM><STRONG>_</STRONG><EM>checkpoint</EM> function  is  the  underlying  function
       used by the <STRONG><A HREF="db_checkpoint.html">db_checkpoint(1)</A></STRONG> utility.  See the source code
       for the <EM>db</EM><STRONG>_</STRONG><EM>checkpoint</EM> utility  for  an  example  of  using
       <EM>txn</EM><STRONG>_</STRONG><EM>checkpoint</EM> in a UNIX environment.

  <EM>txn</EM><STRONG>_</STRONG><EM>stat</EM>
       The  <EM>txn</EM><STRONG>_</STRONG><EM>stat</EM> function creates a statistical structure and
       copies a pointer to  it  into  the  user-specified  memory
       The  transaction  region statistics are stored in a struc-
       ture of type DB_TXN_STAT (typedef'd in &lt;db.h&gt;).  The  fol-
       lowing DB_TXN_STAT fields will be filled in:

       DB_LSN st_last_ckp;
            The LSN of the last checkpoint.
       DB_LSN st_pending_ckp;
            The  LSN  of  any  checkpoint  that  is  currently in
            progress.   If  <EM>st</EM><STRONG>_</STRONG><EM>pending</EM><STRONG>_</STRONG><EM>ckp</EM>   is   the   same   as
            <EM>st</EM><STRONG>_</STRONG><EM>last</EM><STRONG>_</STRONG><EM>ckp</EM> there is no checkpoint in progress.
       time_t st_time_ckp;
            The  time  the last completed checkpoint finished (as
            returned by <STRONG><A HREF="time.html">time(2)</A></STRONG>).
       u_int32_t st_last_txnid;
            The last transaction ID allocated.
       u_int32_t st_maxtxns;
            The maximum number of active  transactions  supported
            by the region.
       u_int32_t st_naborts;
            The number of transactions that have aborted.
       u_int32_t st_nactive;
            The number of transactions that are currently active.
       u_int32_t st_nbegins;
            The number of transactions that have begun.
       u_int32_t st_ncommits;
            The number of transactions that have committed.
       DB_TXN_ACTIVE *st_txnarray;
            A pointer to an  array  of  <EM>st</EM><STRONG>_</STRONG><EM>nactive</EM>  DB_TXN_ACTIVE
            structures,  describing the currently active transac-
            tions.  The following  fields  of  the  DB_TXN_ACTIVE
            structure (typedef'd in &lt;db.h&gt;) will be filled in:


            u_int32_t txnid;
                 The  transaction ID as returned by <STRONG><A HREF="txn_begin.html">txn_begin(3)</A></STRONG>.
            DB_LSN lsn;
                 The LSN of the transaction-begin record.

</PRE>
<H2>TRANSACTIONS</H2><PRE>
       Creating transaction protected applications using  the  DB
       access  methods  requires little system customization.  In
       most cases, the default parameters to  the  locking,  log-
       ging,  memory  pool,  and transaction subsystems will suf-
       fice.  Applications can use <STRONG><A HREF="db_appinit.html">db_appinit(3)</A></STRONG> to perform  this
       initialization, or they may do it explicitly.

       Each  database  operation  (i.e.,  any  call to a function
       underlying the handles returned by <STRONG><A HREF="db_open.html">db_open(3)</A></STRONG> and  <EM>db</EM><STRONG>_</STRONG><EM>cur-</EM>
       <STRONG><A HREF="sor.html">sor(3)</A></STRONG>)  is  normally  performed  on  behalf  of  a unique
       locker.  If multiple calls on behalf of  the  same  locker
       are desired, then transactions must be used.

       Once  the  application  has  initialized the DB subsystems
       that it is  using,  it  may  open  the  DB  access  method
       databases.   For applications performing transactions, the
       application is ready to exit, all outstanding transactions
       should have been committed or aborted.  At this point, all
       open DB files should be  closed.   Once  the  DB  database
       files  are  closed,  the  DB  subsystems should be closed,
       either explicitly or by calling <STRONG><A HREF="db_appexit.html">db_appexit(3)</A></STRONG>.

       It is also possible to use the locking, logging and trans-
       action  subsystems  of DB to provide transaction semantics
       to objects other than those described  by  the  DB  access
       methods.   In  these cases, the application will need more
       explicit customization of the subsystems as  well  as  the
       development  of appropriate data-structure-specific recov-
       ery functions.

       For example, consider an application that provides  trans-
       action  semantics  to  data  stored  in  plain  UNIX files
       accessed using the <STRONG><A HREF="read.html">read(2)</A></STRONG> and <STRONG><A HREF="write.html">write(2)</A></STRONG> system calls.  The
       operations for which transaction protection is desired are
       bracketed by calls to <EM>txn</EM><STRONG>_</STRONG><EM>begin</EM> and <EM>txn</EM><STRONG>_</STRONG><EM>commit</EM>.

       Before data are referenced, the application  must  make  a
       call  to  the  lock  manager,  <EM>db</EM><STRONG>_</STRONG><EM>lock</EM>,  for a lock of the
       appropriate type (e.g., read) on the object being  locked.
       The object might be a page in the file, a byte, a range of
       bytes, or some key.  It is up to the application to ensure
       that  appropriate  locks  are acquired.  Before a write is
       performed, the application should acquire a write lock  on
       the object, by making an appropriate call to the lock man-
       ager, <EM>db</EM><STRONG>_</STRONG><EM>lock</EM>.  Then, the application should make  a  call
       to  the  log manager, <EM>db</EM><STRONG>_</STRONG><EM>log</EM>, to record enough information
       to redo the operation in case of failure after commit  and
       to  undo  the operation in case of abort.  As discussed in
       the <STRONG><A HREF="db_log.html">db_log(3)</A></STRONG> manual page, the application is  responsible
       for  providing  any necessary structure to the log record.
       For example, the application must understand what part  of
       the  log record is an operation code, what part identifies
       the file being modified, what part  is  redo  information,
       and what part is undo information.

       After  the  log  message  is  written, the application may
       issue the write  system  call.   After  all  requests  are
       issued,   the   application  may  call  <EM>txn</EM><STRONG>_</STRONG><EM>commit</EM>.   When
       <EM>txn</EM><STRONG>_</STRONG><EM>commit</EM> returns, the caller is guaranteed that all nec-
       essary log writes have been written to disk.

       At  any  time,  the  application may call <EM>txn</EM><STRONG>_</STRONG><EM>abort</EM>, which
       will result in the appropriate calls to the <EM>recover</EM>  func-
       tion  to  restore  the  ``database''  to a consistent pre-
       transaction state.  (The recover function must be able  to
       either  re-apply  or undo the update depending on the con-
       text, for each different type of log record.)

       If the application should crash, the recovery process uses
       the  <EM>db</EM><STRONG>_</STRONG><EM>log</EM> interface to read the log and call the <EM>recover</EM>


</PRE>
<H2>ENVIRONMENT VARIABLES</H2><PRE>
       The  following  environment variables affect the execution
       of <EM>db</EM><STRONG>_</STRONG><EM>txn</EM>:

       DB_HOME
            If the <EM>dbenv</EM> argument  to  <EM>txn</EM><STRONG>_</STRONG><EM>open</EM>  was  initialized
            using  <EM>db</EM><STRONG>_</STRONG><EM>appinit</EM>,  the  environment variable DB_HOME
            may be used as the path of the database home for  the
            interpretation  of  the  <EM>dir</EM> argument to <EM>txn</EM><STRONG>_</STRONG><EM>open</EM>, as
            described in <STRONG><A HREF="db_appinit.html">db_appinit(3)</A></STRONG>.


       TMPDIR
            If the <EM>dbenv</EM> argument to <EM>txn</EM><STRONG>_</STRONG><EM>open</EM>  was  NULL  or  not
            initialized  using  <EM>db</EM><STRONG>_</STRONG><EM>appinit</EM>, the environment vari-
            able TMPDIR may be used as the directory in which  to
            create  the  transaction  region, as described in the
            <EM>txn</EM><STRONG>_</STRONG><EM>open</EM> section above.


</PRE>
<H2>ERRORS</H2><PRE>
       The <EM>txn</EM><STRONG>_</STRONG><EM>open</EM> function may fail and return <EM>errno</EM> for any of
       the  errors  specified  for  the  following DB and library
       functions: <STRONG><A HREF="close.html">close(2)</A></STRONG>, <STRONG><A HREF="db_version.html">db_version(3)</A></STRONG>, <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>,
       <STRONG><A HREF="lseek.html">lseek(2)</A></STRONG>, <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG>, <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>, <STRONG><A HREF="memset.html">memset(3)</A></STRONG>, <STRONG><A HREF="mmap.html">mmap(2)</A></STRONG>,
       <STRONG><A HREF="munmap.html">munmap(2)</A></STRONG>, <STRONG><A HREF="open.html">open(2)</A></STRONG>, <STRONG><A HREF="sigfillset.html">sigfillset(3)</A></STRONG>, <STRONG><A HREF="sigprocmask.html">sigprocmask(2)</A></STRONG>,
       <STRONG><A HREF="stat.html">stat(2)</A></STRONG>, <STRONG><A HREF="strcpy.html">strcpy(3)</A></STRONG>, <STRONG><A HREF="strdup.html">strdup(3)</A></STRONG>, <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>, <STRONG><A HREF="strlen.html">strlen(3)</A></STRONG>,
       <STRONG><A HREF="time.html">time(3)</A></STRONG>, <STRONG><A HREF="txn_unlink.html">txn_unlink(3)</A></STRONG>, <STRONG><A HREF="unlink.html">unlink(2)</A></STRONG>, and <STRONG><A HREF="write.html">write(2)</A></STRONG>.

       In addition, the <EM>txn</EM><STRONG>_</STRONG><EM>open</EM> function may fail and return <EM>er-</EM>
       <EM>rno</EM> for the following conditions:

       [EINVAL]
            An invalid flag value or parameter was specified.

            The  DB_THREAD  flag  was specified and spinlocks are
            not implemented for this architecture.

            The <EM>dbenv</EM> parameter was NULL.

       [EAGAIN]
            The shared memory region was locked and  (repeatedly)
            unavailable.

       The  <EM>txn</EM><STRONG>_</STRONG><EM>begin</EM>  function may fail and return <EM>errno</EM> for any
       of the errors specified for the following DB  and  library
       functions: <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="log_put.html">log_put(3)</A></STRONG>, <STRONG><A HREF="lseek.html">lseek(2)</A></STRONG>,
       <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG>, <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>, <STRONG><A HREF="memset.html">memset(3)</A></STRONG>, <STRONG><A HREF="mmap.html">mmap(2)</A></STRONG>, <STRONG><A HREF="munmap.html">munmap(2)</A></STRONG>,
       <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>, and <STRONG><A HREF="write.html">write(2)</A></STRONG>.

       In  addition,  the  <EM>txn</EM><STRONG>_</STRONG><EM>begin</EM> function may fail and return
       <EM>errno</EM> for the following conditions:

       [ENOSPC]


       In  addition,  the <EM>txn</EM><STRONG>_</STRONG><EM>commit</EM> function may fail and return
       <EM>errno</EM> for the following conditions:

       [EINVAL]
            The transaction was aborted.

       The <EM>txn</EM><STRONG>_</STRONG><EM>abort</EM> function may fail and return <EM>errno</EM>  for  any
       of  the  errors specified for the following DB and library
       functions: DBenv-&gt;<STRONG><A HREF="tx_recover.html">tx_recover(3)</A></STRONG>, <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>,
       <STRONG><A HREF="lock_vec.html">lock_vec(3)</A></STRONG>, <STRONG><A HREF="log_get.html">log_get(3)</A></STRONG>, <STRONG><A HREF="memset.html">memset(3)</A></STRONG>, and <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>.

       [EINVAL]
            The transaction was already aborted.

       The  <EM>txn</EM><STRONG>_</STRONG><EM>checkpoint</EM> function may fail and return <EM>errno</EM> for
       any of the errors specified for the following DB  and  li-
       brary functions: <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="log_compare.html">log_compare(3)</A></STRONG>,
       <STRONG><A HREF="log_put.html">log_put(3)</A></STRONG>, <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG>, <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>, <STRONG><A HREF="memp_sync.html">memp_sync(3)</A></STRONG>, <STRONG><A HREF="memset.html">memset(3)</A></STRONG>,
       <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>, and <STRONG><A HREF="time.html">time(3)</A></STRONG>.

       [EINVAL]
            An invalid flag value or parameter was specified.

       The  <EM>txn</EM><STRONG>_</STRONG><EM>close</EM>  function may fail and return <EM>errno</EM> for any
       of the errors specified for the following DB  and  library
       functions: <STRONG><A HREF="close.html">close(2)</A></STRONG>, <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="log_flush.html">log_flush(3)</A></STRONG>,
       <STRONG><A HREF="munmap.html">munmap(2)</A></STRONG>, <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>, and <STRONG><A HREF="txn_abort.html">txn_abort(3)</A></STRONG>.

       The <EM>txn</EM><STRONG>_</STRONG><EM>unlink</EM> function may fail and return <EM>errno</EM> for  any
       of  the  errors specified for the following DB and library
       functions: <STRONG><A HREF="close.html">close(2)</A></STRONG>, <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG>,
       <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>, <STRONG><A HREF="memset.html">memset(3)</A></STRONG>, <STRONG><A HREF="mmap.html">mmap(2)</A></STRONG>, <STRONG><A HREF="munmap.html">munmap(2)</A></STRONG>, <STRONG><A HREF="open.html">open(2)</A></STRONG>,
       <STRONG><A HREF="sigfillset.html">sigfillset(3)</A></STRONG>, <STRONG><A HREF="sigprocmask.html">sigprocmask(2)</A></STRONG>, <STRONG><A HREF="stat.html">stat(2)</A></STRONG>, <STRONG><A HREF="strcpy.html">strcpy(3)</A></STRONG>,
       <STRONG><A HREF="strdup.html">strdup(3)</A></STRONG>, <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>, <STRONG><A HREF="strlen.html">strlen(3)</A></STRONG>, and <STRONG><A HREF="unlink.html">unlink(2)</A></STRONG>.

       In  addition,  the <EM>txn</EM><STRONG>_</STRONG><EM>unlink</EM> function may fail and return
       <EM>errno</EM> for the following conditions:

       [EBUSY]
            The shared memory region was in  use  and  the  force
            flag was not set.

       The <EM>txn</EM><STRONG>_</STRONG><EM>stat</EM> function may fail and return <EM>errno</EM> for any of
       the errors specified for  the  following  DB  and  library
       functions: <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, and <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG>.


</PRE>
<H2>SEE ALSO</H2><PRE>
       <EM>LIBTP:</EM>  <EM>Portable,</EM>  <EM>Modular</EM>  <EM>Transactions</EM>  <EM>for</EM>  <EM>UNIX</EM>, Margo
       Seltzer, Michael Olson, USENIX proceedings, Winter 1992.


</PRE>
<H2>BUGS</H2><PRE>
       Nested transactions are not yet implemented.
</PRE>
</BODY>
</HTML>
