<HTML>
<HEAD>
<TITLE>DbTxn</TITLE>
</HEAD>
<BODY>
<H1>DbTxn</H1>
<HR>
<PRE>

</PRE>
<H2>NAME</H2><PRE>
       DbTxn - Db transaction management


</PRE>
<H2>SYNOPSIS</H2><PRE>
       <STRONG>#include</STRONG> <STRONG>&lt;db_cxx.h&gt;</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DbTxn::prepare();</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DbTxn::commit();</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DbTxn::abort();</STRONG>

       <STRONG>u_int32_t</STRONG>
       <STRONG>DbTxn::id();</STRONG>


</PRE>
<H2>DESCRIPTION</H2><PRE>
       The DB library is a family of classes that provides a mod-
       ular programming interface to transactions and record-ori-
       ented  file  access.   The  library  includes  support for
       transactions, locking, logging and file page  caching,  as
       well  as  various  indexed  access  methods.   Many of the
       classes (e.g., the file page  caching  class)  are  useful
       independent of the other DB classes, although some classes
       are explicitly based on other classes (e.g.,  transactions
       and  logging).   For a general description of the DB pack-
       age, see <STRONG><A HREF="db_intro.html">db_intro(3)</A></STRONG>.

       This manual page describes the specific details of the  Db
       transaction  support.  The DbTxn class is used in conjunc-
       tion with <STRONG><A HREF="DbTxnMgr.html">DbTxnMgr(3)</A></STRONG> to  provide  transaction  semantics.
       Full  transaction  support  is provided by a collection of
       modules that provide interfaces to the  services  required
       for  transaction  processing.  These services are recovery
       (see <STRONG><A HREF="DbLog.html">DbLog(3)</A></STRONG>), concurrency  control  (see  <STRONG><A HREF="DbLock.html">DbLock(3)</A></STRONG>  and
       <STRONG><A HREF="DbLockTab.html">DbLockTab(3)</A></STRONG>), and the management of shared data (see <EM>DbM-</EM>
       <STRONG><A HREF="pool.html">pool(3)</A></STRONG> and <STRONG><A HREF="DbMpoolFile.html">DbMpoolFile(3)</A></STRONG>).  Transaction semantics can be
       applied  to  the access methods described in <STRONG><A HREF="Db.html">Db(3)</A></STRONG> through
       method call parameters.

       The model intended for transactional use (and that is used
       by the access methods) is that write-ahead logging is pro-
       vided by <STRONG><A HREF="DbLog.html">DbLog(3)</A></STRONG> to record both before-  and  after-image
       logging.   Locking follows a two-phase protocol (i.e., all
       locks are released at transaction commit).

  <EM>DbTxn::prepare</EM>
       The <EM>DbTxn::prepare</EM> method initiates the beginning of a two
       phase  commit.   In a distributed transaction environment,
       <EM>db</EM> can be used as a local transaction  manager.   In  this
       case,  the  distributed transaction manager must send <EM>pre-</EM>
       <EM>pare</EM> messages to each local manager.   The  local  manager
       commit log record is written and flushed to disk,  as  are
       all previously written log records.  If the transaction is
       nested, its locks are acquired by the parent  transaction,
       otherwise  its  locks are released.  Any applications that
       require strict two-phase  locking  must  not  release  any
       locks  explicitly,  leaving  them  all  to  be released by
       <EM>DbTxn::commit</EM>.

       The  <EM>DbTxn::commit</EM>  method  throws  a  <STRONG><A HREF="DbException.html">DbException(3)</A></STRONG>   or
       returns the value of <EM>errno</EM> on failure and 0 on success.

  <EM>DbTxn::abort</EM>
       The  <EM>DbTxn::abort</EM> method causes an abnormal termination of
       the transaction.  The log is played backwards and any nec-
       essary  recovery  operations  are  initiated  through  the
       <EM>recover</EM> method specified to <EM>DbTxnMgr::open</EM>.  After  recov-
       ery  is  completed,  all locks held by the transaction are
       acquired by the parent transaction in the case of a nested
       transaction or released in the case of a non-nested trans-
       action.  As is the case  for  <EM>DbTxn::commit</EM>,  applications
       that  require  strict two phase locking should not explic-
       itly release any locks.

       The <EM>DbTxn::abort</EM> method throws a <STRONG><A HREF="DbException.html">DbException(3)</A></STRONG> or returns
       the value of <EM>errno</EM> on failure and 0 on success.

  <EM>DbTxn::id</EM>
       The  <EM>DbTxn::id</EM>  method  returns  the unique transaction id
       associated with the specified transaction.  Locking  calls
       made  on  behalf  of this transaction should use the value
       returned from <EM>DbTxn::id</EM> as the  locker  parameter  to  the
       <EM>DbLockTab::get</EM> or <EM>DbLockTab::vec</EM> calls.



</PRE>
<H2>TRANSACTIONS</H2><PRE>
       Creating  transaction  protected applications using the Db
       access methods requires little system  customization.   In
       most  cases,  the  default parameters to the locking, log-
       ging, memory pool, and transaction  subsystems  will  suf-
       fice.   Applications can use <EM>DbEnv::appinit</EM> (see <STRONG><A HREF="DbEnv.html">DbEnv(3)</A></STRONG>)
       to perform this initialization, or they may do it  explic-
       itly.

       Each database operation (i.e., any call to a method under-
       lying the handles  returned  by  <EM>Db::open</EM>  and  <EM>Db::cursor</EM>
       described  in  <STRONG><A HREF="Db.html">Db(3)</A></STRONG>) is normally performed on behalf of a
       unique locker.  If multiple calls on behalf  of  the  same
       locker are desired, then transactions must be used.

       Once  the  application  has  initialized the Db subsystems
       that it is  using,  it  may  open  the  Db  access  method
       databases.   For applications performing transactions, the
       databases must be opened after  subsystem  initialization,
       and  cannot  be opened as part of a transaction.  Once the
       open Db files should be  closed.   Once  the  Db  database
       files  are  closed,  the  Db  subsystems should be closed,
       either explicitly or by destroying the <STRONG><A HREF="DbEnv.html">DbEnv(3)</A></STRONG> object.

       It is also possible to use the locking, logging and trans-
       action  subsystems  of Db to provide transaction semantics
       to objects other than those described  by  the  Db  access
       methods.   In  these cases, the application will need more
       explicit customization of the subsystems as  well  as  the
       development  of appropriate data-structure-specific recov-
       ery functions.

       For example, consider an application that provides  trans-
       action  semantics  to  data  stored  in  plain  UNIX files
       accessed using the <STRONG><A HREF="read.html">read(2)</A></STRONG> and <STRONG><A HREF="write.html">write(2)</A></STRONG> system calls.  The
       operations for which transaction protection is desired are
       bracketed by calls to <EM>DbTxnMgr::begin</EM> and <EM>DbTxn::commit</EM>.

       Before data are referenced, the application  must  make  a
       call  to  the  lock  manager, <STRONG><A HREF="DbLock.html">DbLock(3)</A></STRONG>, for a lock of the
       appropriate type (e.g., read) on the object being  locked.
       The object might be a page in the file, a byte, a range of
       bytes, or some key.  It is up to the application to ensure
       that  appropriate  locks  are acquired.  Before a write is
       performed, the application should acquire a write lock  on
       the object, by making an appropriate call to the lock man-
       ager, <STRONG><A HREF="DbLock.html">DbLock(3)</A></STRONG><EM>.</EM>  Then, the application should make a call
       to the log manager, <EM>DbLog</EM>, to record enough information to
       redo the operation in case of failure after commit and  to
       undo  the operation in case of abort.  As discussed in the
       <STRONG><A HREF="DbLog.html">DbLog(3)</A></STRONG> manual page, the application is  responsible  for
       providing  any necessary structure to the log record.  For
       example, the application must understand what part of  the
       log  record is an operation code, what part identifies the
       file being modified, what part is  redo  information,  and
       what part is undo information.

       After  the  log  message  is  written, the application may
       issue the write  system  call.   After  all  requests  are
       issued,  the  application  may  call  <EM>DbTxn::commit</EM>.  When
       <EM>DbTxn::commit</EM> returns, the caller is guaranteed  that  all
       necessary log writes have been written to disk.

       At  any time, the application may call <EM>DbTxn::abort</EM>, which
       will result in the appropriate calls to the <EM>recover</EM> method
       to  restore  the ``database'' to a consistent pre-transac-
       tion state.  (The recover method must be  able  to  either
       re-apply  or undo the update depending on the context, for
       each different type of log record.)

       If the application should crash, the recovery process uses
       the  <EM>DbLog</EM>  interface to read the log and call the <EM>recover</EM>
       method to restore the database to a consistent state.

       Methods  marked as returning <EM>errno</EM> will, by default, throw
       an exception that encapsulates the error information.  The
       default error behavior can be changed, see <STRONG><A HREF="DbException.html">DbException(3)</A></STRONG>.

       The <EM>DbTxn::prepare</EM> method may fail and  throw  a  <EM>DbExcep-</EM>
       <STRONG><A HREF="tion.html">tion(3)</A></STRONG>  or  return  <EM>errno</EM> for any of the errors specified
       for the following DB and library functions:
       DbLog::<STRONG><A HREF="flush.html">flush(3)</A></STRONG>, <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, and <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>.

       The  <EM>DbTxn::commit</EM>  method  may  fail and throw a <EM>DbExcep-</EM>
       <STRONG><A HREF="tion.html">tion(3)</A></STRONG> or return <EM>errno</EM> for any of  the  errors  specified
       for the following DB and library functions:
       DbLockTab::<STRONG><A HREF="vec.html">vec(3)</A></STRONG>, DbLog::<STRONG><A HREF="put.html">put(3)</A></STRONG>, <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>,
       <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG>, <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>, and <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>.

       In addition, the <EM>DbTxn::commit</EM> method may fail and throw a
       <STRONG><A HREF="DbException.html">DbException(3)</A></STRONG> or return <EM>errno</EM> for  the  following  condi-
       tions:

       [EINVAL]
            The transaction was aborted.

       The  <EM>DbTxn::abort</EM>  method  may  fail  and throw a <EM>DbExcep-</EM>
       <STRONG><A HREF="tion.html">tion(3)</A></STRONG> or return <EM>errno</EM> for any of  the  errors  specified
       for the following DB and library functions:
       DBenv-&gt;<STRONG><A HREF="tx_recover.html">tx_recover(3)</A></STRONG>, DbLockTab::<STRONG><A HREF="vec.html">vec(3)</A></STRONG>, DbLog::<STRONG><A HREF="get.html">get(3)</A></STRONG>,
       <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="memset.html">memset(3)</A></STRONG>, and <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>.

       [EINVAL]
            The transaction was already aborted.


</PRE>
<H2>SEE ALSO</H2><PRE>
       <EM>LIBTP:</EM>  <EM>Portable,</EM>  <EM>Modular</EM>  <EM>Transactions</EM>  <EM>for</EM>  <EM>UNIX</EM>, Margo
       Seltzer, Michael Olson, USENIX proceedings, Winter 1992.


</PRE>
<H2>BUGS</H2><PRE>
       Nested transactions are not yet implemented.

       <STRONG><A HREF="db_archive.html">db_archive(1)</A></STRONG>, <STRONG><A HREF="db_checkpoint.html">db_checkpoint(1)</A></STRONG>, <STRONG><A HREF="db_deadlock.html">db_deadlock(1)</A></STRONG>, <STRONG><A HREF="db_dump.html">db_dump(1)</A></STRONG>,
       <STRONG><A HREF="db_load.html">db_load(1)</A></STRONG>, <STRONG><A HREF="db_recover.html">db_recover(1)</A></STRONG>, <STRONG><A HREF="db_stat.html">db_stat(1)</A></STRONG>, <STRONG><A HREF="db_intro.html">db_intro(3)</A></STRONG>, <STRONG><A HREF="db_jump.html">db_jump(3)</A></STRONG>,
       <STRONG><A HREF="db_thread.html">db_thread(3)</A></STRONG>, <STRONG><A HREF="Db.html">Db(3)</A></STRONG>, <STRONG><A HREF="Dbc.html">Dbc(3)</A></STRONG>, <STRONG><A HREF="DbEnv.html">DbEnv(3)</A></STRONG>, <STRONG><A HREF="DbException.html">DbException(3)</A></STRONG>, <STRONG><A HREF="DbInfo.html">DbInfo(3)</A></STRONG>,
       <STRONG><A HREF="DbLock.html">DbLock(3)</A></STRONG>, <STRONG><A HREF="DbLocktab.html">DbLocktab(3)</A></STRONG>, <STRONG><A HREF="DbLog.html">DbLog(3)</A></STRONG>, <STRONG><A HREF="DbLsn.html">DbLsn(3)</A></STRONG>, <STRONG><A HREF="DbMpool.html">DbMpool(3)</A></STRONG>,
       <STRONG><A HREF="DbMpoolFile.html">DbMpoolFile(3)</A></STRONG>, <STRONG><A HREF="Dbt.html">Dbt(3)</A></STRONG>, <STRONG><A HREF="DbTxn.html">DbTxn(3)</A></STRONG>, <STRONG><A HREF="DbTxnMgr.html">DbTxnMgr(3)</A></STRONG>
</PRE>
</BODY>
</HTML>
