<HTML>
<HEAD>
<TITLE>DbLockTab</TITLE>
</HEAD>
<BODY>
<H1>DbLockTab</H1>
<HR>
<PRE>

</PRE>
<H2>NAME</H2><PRE>
       DbLockTab - lock manager


</PRE>
<H2>SYNOPSIS</H2><PRE>
       <STRONG>#include</STRONG> <STRONG>&lt;db_cxx.h&gt;</STRONG>

       <STRONG>static</STRONG> <STRONG>int</STRONG>
       <STRONG>DbLockTab::open(const</STRONG> <STRONG>char</STRONG> <STRONG>*dir,</STRONG>
            <STRONG>int</STRONG> <STRONG>flags,</STRONG> <STRONG>int</STRONG> <STRONG>mode,</STRONG> <STRONG>DbEnv</STRONG> <STRONG>*dbenv,</STRONG> <STRONG>DbLockTab</STRONG> <STRONG>**regionp);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DbLockTab::id(u_int32_t</STRONG> <STRONG>*idp);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DbLockTab::vec(u_int32_t</STRONG> <STRONG>locker,</STRONG> <STRONG>int</STRONG> <STRONG>flags,</STRONG>
            <STRONG>DB_LOCKREQ</STRONG> <STRONG>list[],</STRONG> <STRONG>int</STRONG> <STRONG>nlist,</STRONG> <STRONG>DB_LOCKREQ</STRONG> <STRONG>**elistp);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DbLockTab::get(u_int32_t</STRONG> <STRONG>locker,</STRONG> <STRONG>int</STRONG> <STRONG>flags,</STRONG>
            <STRONG>const</STRONG> <STRONG>Dbt</STRONG> <STRONG>*obj,</STRONG> <STRONG>const</STRONG> <STRONG>db_lockmode_t</STRONG> <STRONG>lock_mode,</STRONG> <STRONG>DB_LOCK</STRONG> <STRONG>*lock);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DbLockTab::close();</STRONG>

       <STRONG>static</STRONG> <STRONG>int</STRONG>
       <STRONG>DbLockTab::unlink(const</STRONG> <STRONG>char</STRONG> <STRONG>*dir,</STRONG> <STRONG>int</STRONG> <STRONG>force,</STRONG> <STRONG>DbEnv</STRONG> <STRONG>*dbenv);</STRONG>

       <STRONG>int</STRONG>
       <STRONG>DbLockTab::detect(db_detect_t</STRONG> <STRONG>atype,</STRONG> <STRONG>int</STRONG> <STRONG>flags);</STRONG>


</PRE>
<H2>DESCRIPTION</H2><PRE>
       The DB library is a family of classes that provides a mod-
       ular programming interface to transactions and record-ori-
       ented  file  access.   The  library  includes  support for
       transactions, locking, logging and file page  caching,  as
       well  as  various  indexed  access  methods.   Many of the
       classes (e.g., the file page  caching  class)  are  useful
       independent of the other DB classes, although some classes
       are explicitly based on other classes (e.g.,  transactions
       and  logging).   For a general description of the DB pack-
       age, see <STRONG><A HREF="db_intro.html">db_intro(3)</A></STRONG>.

       This manual page describes the  specific  details  of  the
       locking interface.

       The <EM>DbLockTab</EM> class is intended to provide general-purpose
       locking.  While designed to work with the other  Db  func-
       tions,  this class is also useful for more general locking
       purposes.  Locks can be shared between processes.  In most
       cases,  when  multiple treads or processes are using lock-
       ing, the deadlock detector, <STRONG><A HREF="db_deadlock.html">db_deadlock(1)</A></STRONG>, should be run.

  <EM>DbLockTab::open</EM>
       The  <EM>DbLockTab::open</EM>  method copies a pointer, to the lock
       directory it specifies.  If none  of  them  are  set,  the
       first  possible  one of the following directories is used:
       <EM>/var/tmp</EM>, <EM>/usr/tmp</EM>, <EM>/temp</EM>, <EM>/tmp</EM>, <EM>C:/temp</EM> and <EM>C:/tmp</EM>.

       All files associated with the lock table  are  created  in
       this directory.  This directory must already exist when <EM>is</EM>
       <EM>called.</EM>  If the lock table  already  exists,  the  process
       must have permission to read and write the existing files.
       If the lock table does not already exist, it is optionally
       created and initialized.

       The  <EM>flags</EM>  and  <EM>mode</EM>  arguments specify how files will be
       opened and/or created when they don't already exist.   The
       flags value is specified by <STRONG>or</STRONG>'ing together one or more of
       the following values:

       DB_CREATE
            Create any underlying files, as  necessary.   If  the
            files  do not already exist and the DB_CREATE flag is
            not specified, the call will fail.

       DB_THREAD
            Cause the DbLockTab handle returned  by  the  <EM>DbLock-</EM>
            <EM>Tab::open</EM>  method  to  be useable by multiple threads
            within a single address space, i.e.,  to  be  ``free-
            threaded''.

       All  files  created by the lock subsystem are created with
       mode <EM>mode</EM> (as described in <STRONG><A HREF="chmod.html">chmod(2)</A></STRONG>) and modified  by  the
       process'   umask  value  at  the  time  of  creation  (see
       <STRONG><A HREF="umask.html">umask(2)</A></STRONG>).  The group ownership of created files is  based
       on  the  system and directory defaults, and is not further
       specified by DB.

       The locking subsystem is configured  based  on  which  set
       methods  have been used.  It is expected that applications
       will use a single DbEnv object as the argument to  all  of
       the subsystems in the DB package.  The fields of the DbEnv
       object used by <EM>DbLockTab::open</EM> are  described  below.   As
       references  to  the  DbEnv  object  may  be  maintained by
       <EM>DbLockTab::open</EM>, it is necessary that the DbEnv object and
       memory   it  references  be  valid  until  the  object  is
       destroyed.  Any of the DbEnv fields that are  not  explic-
       itly set will default to appropriate values.

       The  following  fields in the DbEnv object may be initial-
       ized, using the appropriate  set  method,  before  calling
       <EM>DbLockTab::open</EM>:


       void *(*db_errcall)(char *db_errpfx, char *buffer);
       FILE *db_errfile;
       const char *db_errpfx;
       class ostream *db_error_stream;
            If   <EM>lk</EM><STRONG>_</STRONG><EM>conflicts</EM>   is   NULL,  the  conflicts  array
            <EM>db</EM><STRONG>_</STRONG><EM>rw</EM><STRONG>_</STRONG><EM>conflicts</EM> is used; see the section below  enti-
            tled  ``STANDARD  LOCK  MODES''  for a description of
            that array.

       db_detect_t lk_detect;
            If non-0, specifies that the deadlock detector be run
            whenever  a lock conflict occurs, and specifies which
            transaction should be aborted in the case of a  dead-
            lock.   The <EM>lk</EM><STRONG>_</STRONG><EM>detect</EM> field must be set to one of the
            following values.

            DB_LOCK_DEFAULT
                 Use the  default  policy  as  specified  in  the
                 <STRONG><A HREF="db_deadlock.html">db_deadlock(1)</A></STRONG> man page.

            DB_LOCK_OLDEST
                 Abort the oldest transaction.

            DB_LOCK_RANDOM
                 Abort a random transaction involved in the dead-
                 lock.

            DB_LOCK_YOUNGEST
                 Abort the youngest transaction.

       unsigned int lk_max;
            The maximum number of locks to be held  or  requested
            in  the table.  This value is used by <EM>DbLockTab::open</EM>
            to estimate how much space to  allocate  for  various
            lock-table data structures.  If <EM>lk</EM><STRONG>_</STRONG><EM>max</EM> is not explic-
            itly set, a default value is used.

       int lk_modes;
            The number of lock modes to be recognized by the lock
            table   (including  the  ``not-granted''  mode).   If
            <EM>lk</EM><STRONG>_</STRONG><EM>modes</EM> is 0, the value DB_LOCK_RW_N  is  used;  see
            below for a description of that value.

       The  <EM>DbLockTab::open</EM>  method  throws  a  <STRONG><A HREF="DbException.html">DbException(3)</A></STRONG> or
       returns the value of <EM>errno</EM> on failure and 0 on success.

  <EM>DbLockTab::id</EM>
       The <EM>DbLockTab::id</EM> method copies  a  locker  ID,  which  is
       guaranteed  to be unique in the specified lock table, into
       the memory location referenced by <EM>idp</EM>.

       The access methods (see <EM>Db::open</EM>  in  <STRONG><A HREF="Db.html">Db(3)</A></STRONG>),  generate  a
       unique  locker  ID for each file that is opened with lock-
       ing.  During Db access method operation,  this  locker  ID
       will be used for all lock calls unless a transaction iden-
       tifier was specified for  the  call,  in  which  case  the
       transaction ID specified is used for locking.

       unsigned  32-bit  integer  quantity.   It  represents  the
       entity requesting or releasing the lock.

       The <EM>flags</EM> value must be set to 0 or the following value:

       DB_LOCK_NOWAIT
            If  a  lock  cannot  be granted because the requested
            lock conflicts with an existing lock, return  immedi-
            ately  instead  of  waiting  for  the  lock to become
            available.

       The <EM>list</EM> array provided to <EM>DbLockTab::vec</EM> is typedef'd  in
       &lt;db_cxx.h&gt;  as  DB_LOCKREQ.  A DB_LOCKREQ structure has at
       least the following  fields,  which  must  be  initialized
       before calling <EM>DbLockTab::vec</EM>:

       lockop_t op;
            The  operation  to be performed, which must be set to
            one of the following values:

            DB_LOCK_GET
                 Get a lock, as defined by the values of  <EM>locker</EM>,
                 <EM>obj</EM>  and <EM>mode</EM>.  Upon return from <EM>DbLockTab::vec</EM>,
                 if the <EM>lock</EM> field is non-NULL,  a  reference  to
                 the acquired lock is stored there.  (This refer-
                 ence is  invalidated  by  any  call  to  <EM>DbLock-</EM>
                 <EM>Tab::vec</EM> or <EM>DbLock::put</EM> that releases the lock.)
                 See <STRONG><A HREF="DbLock.html">DbLock(3)</A></STRONG>.

            DB_LOCK_PUT
                 The lock referenced by the contents of the  <EM>lock</EM>
                 field is released.

            DB_LOCK_PUT_ALL
                 All locks held by the <EM>locker</EM> are released.  (Any
                 locks acquired as a part of the current call  to
                 <EM>DbLockTab::vec</EM>    that    appear    after    the
                 DB_LOCK_PUT_ALL entry  are  not  considered  for
                 this operation).

            DB_LOCK_PUT_OBJ
                 All locks held by the <EM>locker</EM>, on the object <EM>obj</EM>,
                 with  the  mode  specified  by  <EM>lock</EM><STRONG>_</STRONG><EM>mode</EM>,   are
                 released.   A  <EM>lock</EM><STRONG>_</STRONG><EM>mode</EM> of DB_LOCK_NG indicates
                 that all locks on the object should be released.
                 Note  that  any  locks acquired as a part of the
                 current call to <EM>DbLockTab::vec</EM> that occur before
                 the DB_LOCK_PUT_OBJ will also be released; those
                 acquired afterwards will not be released.

       const Dbt obj;
            An untyped byte string that specifies the  object  to
            be locked or released.

       tions  before the failing operation are guaranteed to have
       completed successfully, and <EM>DbLockTab::vec</EM> returns a  non-
       zero value.  In addition, if <EM>elistp</EM> is not NULL, it is set
       to point to the DB_LOCKREQ entry that was being  processed
       when the error occurred.


       In  the case of an error, <EM>DbLockTab::vec</EM> may return one of
       the following values:

       DB_LOCK_DEADLOCK
            The specified <EM>locker</EM> was  selected  as  a  victim  in
            order to resolve a deadlock.

       DB_LOCK_NOTHELD
            The  lock  cannot  be released, as it was not held by
            the <EM>locker</EM>.

       DB_LOCK_NOTGRANTED
            A lock was requested that could not  be  granted  and
            the  <EM>flag</EM>  parameter  was  set to DB_LOCK_NOWAIT.  In
            this case, if non-NULL, <EM>elistp</EM> identifies the request
            that was granted.

       Otherwise,  the  <EM>DbLockTab::vec</EM>  method  throws a <EM>DbExcep-</EM>
       <STRONG><A HREF="tion.html">tion(3)</A></STRONG> or returns the value of <EM>errno</EM> on failure and 0  on
       success.

  <EM>DbLockTab::get</EM>
       The  <EM>DbLockTab::get</EM>  method  is  a simple interface to the
       <EM>DbLockTab::vec</EM> functionality, and is equivalent to calling
       the <EM>DbLockTab::vec</EM> method with the <EM>locker</EM> argument, <EM>elistp</EM>
       and <EM>conflict</EM> arguments, and a single element  <EM>list</EM>  array,
       for  which  the  <EM>op</EM>  field  is  DB_LOCK_GET,  and the <EM>obj</EM>,
       <EM>lock</EM><STRONG>_</STRONG><EM>mode</EM> and <EM>lock</EM> fields are represented by the arguments
       of  the same name.  Note that the type of the <EM>obj</EM> argument
       to <EM>DbLockTab::get</EM> is different from the <EM>obj</EM> element  found
       in  the  DB_LOCKREQ  structure.  The <EM>DbLockTab::get</EM> method
       returns success and failure as described for  the  <EM>DbLock-</EM>
       <EM>Tab::vec</EM> method.

  <EM>DbLockTab::close</EM>
       The <EM>DbLockTab::close</EM> method disassociates the calling pro-
       cess from the lock table.  The object should not  be  used
       after  a  call  to close.  Note that <EM>DbLockTab::close</EM> does
       not release any locks still held by the  closing  process.
       (This  provides functionality for long-lived locks.)  Pro-
       cesses that wish to have all their locks released  can  do
       so by issuing the appropriate <EM>DbLockTab::vec</EM> call.

       In  addition,  if  the <EM>dir</EM> argument to <EM>DbLockTab::open</EM> was
       NULL and <EM>dbenv</EM> was not initialized  using  <EM>DbEnv::appinit</EM>,
       all  files created for this shared region will be removed,
       as if <EM>DbLockTab::unlink</EM> were called.
       removed.)  If there are processes that have called <EM>DbLock-</EM>
       <EM>Tab::open</EM>  without  calling  <EM>DbLockTab::close</EM> (i.e., there
       are processes currently using  the  lock  table),  <EM>DbLock-</EM>
       <EM>Tab::unlink</EM>  will  fail without further action, unless the
       force flag is set, in which  case  <EM>DbLockTab::unlink</EM>  will
       attempt  to  remove the lock table files regardless of any
       processes still using the lock table.

       The result of attempting to forcibly  destroy  the  region
       when  a  process has the region open is unspecified.  Pro-
       cesses using a shared memory region maintain an open  file
       descriptor  for  it.   On UNIX systems, the region removal
       should succeed and processes that have already joined  the
       region  should  continue  to  run  in  the  region without
       change, however processes  attempting  to  join  the  lock
       table  will either fail or attempt to create a new region.
       On other systems, e.g., WNT, where  the  <STRONG><A HREF="unlink.html">unlink(2)</A></STRONG>  system
       call  will fail if any process has an open file descriptor
       for the file, the region removal will fail.

       In the case of catastrophic or  system  failure,  database
       recovery  must  be  performed  (see  <STRONG><A HREF="db_recovery.html">db_recovery(1)</A></STRONG> or the
       DB_RECOVER flags to <EM>DbEnv::</EM><STRONG><A HREF="appinit.html">appinit(3)</A></STRONG>).  Alternatively, if
       recovery  is  not  required  because  no database state is
       maintained across failures, it is possible to clean  up  a
       lock  table  by removing all of the files in the directory
       specified to the <EM>DbLockTab::open</EM>  method,  as  lock  table
       files  are  never  created in any directory other than the
       one specified to  <EM>DbLockTab::open</EM>.   Note,  however,  that
       this  has  the  potential  to  remove files created by the
       other DB subsystems in this database environment.

       The <EM>DbLockTab::unlink</EM> method throws  a  <STRONG><A HREF="DbException.html">DbException(3)</A></STRONG>  or
       returns the value of <EM>errno</EM> on failure and 0 on success.

  <EM>DbLockTab::detect</EM>
       The  <EM>DbLockTab::detect</EM>  method  runs  one iteration of the
       deadlock detector on the table represented  by  DbLockTab.
       The  deadlock  detector  traverses the lock table, detects
       deadlocks, and if it finds one, marks one of the  partici-
       pating transactions for abort and then returns.

       The  <EM>atype</EM>  parameter specifies which transaction to abort
       in the case of deadlock.  It must be set to one of  values
       described  above  for  the  <EM>lk</EM><STRONG>_</STRONG><EM>detect</EM>  field  of the <EM>DbEnv</EM>
       object.

       The flags value is specified by  <STRONG>or</STRONG>'ing  together  one  or
       more of the following values:
       DB_LOCK_CONFLICT
            Only run the deadlock detector if a lock conflict has
            occurred since the last time that the deadlock detec-
            tor was run.


       DB_HOME
            If the <EM>dbenv</EM> argument to <EM>DbLockTab::open</EM> was initial-
            ized  using  <EM>db</EM><STRONG>_</STRONG><EM>appinit</EM>,  the  environment   variable
            DB_HOME  may be used as the path of the database home
            for the interpretation of the <EM>dir</EM> argument to <EM>DbLock-</EM>
            <EM>Tab::open</EM>, as described in <STRONG><A HREF="db_appinit.html">db_appinit(3)</A></STRONG>.

       TMPDIR
            If  the <EM>dbenv</EM> argument to <EM>DbLockTab::open</EM> was NULL or
            not initialized  using  <EM>db</EM><STRONG>_</STRONG><EM>appinit</EM>,  the  environment
            variable TMPDIR may be used as the directory in which
            to create the lock table, as described in the <EM>DbLock-</EM>
            <EM>Tab::open</EM> section above.


</PRE>
<H2>STANDARD LOCK MODES</H2><PRE>
       The  include  file  &lt;db_cxx.h&gt;  declares two commonly used
       conflict arrays:

       const u_int8_t db_lock_rw_conflicts[];
            This is a conflict array for a  simple  scheme  using
            shared and exclusive lock modes.

       const u_int8_t db_lock_riw_conflicts[];
            This is a conflict array that involves various intent
            lock modes (e.g., intent shared) that  are  used  for
            multigranularity locking.

       Their associated sizes are DB_LOCK_RW_N and DB_LOCK_RIW_N.

       In addition, the include file &lt;db_cxx.h&gt; defines the  type
       <EM>db</EM><STRONG>_</STRONG><EM>lockmode</EM><STRONG>_</STRONG><EM>t</EM>,  which  is  the type of the lock modes used
       with the standard tables above:

              DB_LOCK_NG
                   not granted (always 0)

              DB_LOCK_READ
                   read (shared)

              DB_LOCK_WRITE
                   write (exclusive)


</PRE>
<H2>ERRORS</H2><PRE>
       Methods marked as returning <EM>errno</EM> will, by default,  throw
       an exception that encapsulates the error information.  The
       default error behavior can be changed, see <STRONG><A HREF="DbException.html">DbException(3)</A></STRONG>.

       The  <EM>DbLockTab::open</EM>  method may fail and throw a <EM>DbExcep-</EM>
       <STRONG><A HREF="tion.html">tion(3)</A></STRONG> or return <EM>errno</EM> for any of  the  errors  specified
       for the following DB and library functions:
       DbLock::<STRONG><A HREF="unlink.html">unlink(3)</A></STRONG>, <STRONG><A HREF="close.html">close(2)</A></STRONG>, <STRONG><A HREF="db_version.html">db_version(3)</A></STRONG>, <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>,
       <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="lseek.html">lseek(2)</A></STRONG>, <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG>, <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>, <STRONG><A HREF="memset.html">memset(3)</A></STRONG>,
       <STRONG><A HREF="mmap.html">mmap(2)</A></STRONG>, <STRONG><A HREF="munmap.html">munmap(2)</A></STRONG>, <STRONG><A HREF="open.html">open(2)</A></STRONG>, <STRONG><A HREF="sigfillset.html">sigfillset(3)</A></STRONG>,
            An invalid flag value or parameter was specified.

            The  DB_THREAD  flag  was specified and spinlocks are
            not implemented for this architecture.

       The <EM>DbLockTab::vec</EM> method may fail and  throw  a  <EM>DbExcep-</EM>
       <STRONG><A HREF="tion.html">tion(3)</A></STRONG>  or  return  <EM>errno</EM> for any of the errors specified
       for the following DB and library functions:
       DbLock::<STRONG><A HREF="detect.html">detect(3)</A></STRONG>, <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="lseek.html">lseek(2)</A></STRONG>,
       <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>, <STRONG><A HREF="memset.html">memset(3)</A></STRONG>, <STRONG><A HREF="mmap.html">mmap(2)</A></STRONG>, <STRONG><A HREF="munmap.html">munmap(2)</A></STRONG>, <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>, and
       <STRONG><A HREF="write.html">write(2)</A></STRONG>.

       In  addition, the <EM>DbLockTab::vec</EM> method may fail and throw
       a <STRONG><A HREF="DbException.html">DbException(3)</A></STRONG> or return <EM>errno</EM> for the following  condi-
       tions:

       [EACCES]
            An  attempt  was made to release lock held by another
            locker.

       [EINVAL]
            An invalid flag value or parameter was specified.

       The <EM>DbLockTab::get</EM> method may fail and  throw  a  <EM>DbExcep-</EM>
       <STRONG><A HREF="tion.html">tion(3)</A></STRONG>  or  return  <EM>errno</EM> for any of the errors specified
       for the following DB and library functions:
       DbLock::<STRONG><A HREF="detect.html">detect(3)</A></STRONG>, <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="lseek.html">lseek(2)</A></STRONG>,
       <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>, <STRONG><A HREF="memset.html">memset(3)</A></STRONG>, <STRONG><A HREF="mmap.html">mmap(2)</A></STRONG>, <STRONG><A HREF="munmap.html">munmap(2)</A></STRONG>, <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>, and
       <STRONG><A HREF="write.html">write(2)</A></STRONG>.

       In  addition, the <EM>DbLockTab::get</EM> method may fail and throw
       a <STRONG><A HREF="DbException.html">DbException(3)</A></STRONG> or return <EM>errno</EM> for the following  condi-
       tions:

       [EINVAL]
            An invalid flag value or parameter was specified.

       The  <EM>DbLockTab::close</EM> method may fail and throw a <EM>DbExcep-</EM>
       <STRONG><A HREF="tion.html">tion(3)</A></STRONG> or return <EM>errno</EM> for any of  the  errors  specified
       for the following DB and library functions: <STRONG><A HREF="close.html">close(2)</A></STRONG>,
       <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="munmap.html">munmap(2)</A></STRONG>, and <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>.

       The <EM>DbLockTab::unlink</EM> method may fail and throw a <EM>DbExcep-</EM>
       <STRONG><A HREF="tion.html">tion(3)</A></STRONG>  or  return  <EM>errno</EM> for any of the errors specified
       for the following DB and library functions: <STRONG><A HREF="close.html">close(2)</A></STRONG>,
       <STRONG><A HREF="fcntl.html">fcntl(2)</A></STRONG>, <STRONG><A HREF="fflush.html">fflush(3)</A></STRONG>, <STRONG><A HREF="malloc.html">malloc(3)</A></STRONG>, <STRONG><A HREF="memcpy.html">memcpy(3)</A></STRONG>, <STRONG><A HREF="memset.html">memset(3)</A></STRONG>,
       <STRONG><A HREF="mmap.html">mmap(2)</A></STRONG>, <STRONG><A HREF="munmap.html">munmap(2)</A></STRONG>, <STRONG><A HREF="open.html">open(2)</A></STRONG>, <STRONG><A HREF="sigfillset.html">sigfillset(3)</A></STRONG>,
       <STRONG><A HREF="sigprocmask.html">sigprocmask(2)</A></STRONG>, <STRONG><A HREF="stat.html">stat(2)</A></STRONG>, <STRONG><A HREF="strcpy.html">strcpy(3)</A></STRONG>, <STRONG><A HREF="strdup.html">strdup(3)</A></STRONG>,
       <STRONG><A HREF="strerror.html">strerror(3)</A></STRONG>, <STRONG><A HREF="strlen.html">strlen(3)</A></STRONG>, and <STRONG><A HREF="unlink.html">unlink(2)</A></STRONG>.

       In addition, the <EM>DbLockTab::unlink</EM>  method  may  fail  and
       throw  a  <STRONG><A HREF="DbException.html">DbException(3)</A></STRONG> or return <EM>errno</EM> for the following
       conditions:

       held  and are <STRONG>never</STRONG> released.  In this case, all processes
       should exit as quickly as possible, so that <EM>db</EM><STRONG>_</STRONG><EM>recover</EM> can
       be run.


</PRE>
<H2>SEE ALSO</H2><PRE>
       <STRONG><A HREF="db_archive.html">db_archive(1)</A></STRONG>, <STRONG><A HREF="db_checkpoint.html">db_checkpoint(1)</A></STRONG>, <STRONG><A HREF="db_deadlock.html">db_deadlock(1)</A></STRONG>, <STRONG><A HREF="db_dump.html">db_dump(1)</A></STRONG>,
       <STRONG><A HREF="db_load.html">db_load(1)</A></STRONG>, <STRONG><A HREF="db_recover.html">db_recover(1)</A></STRONG>, <STRONG><A HREF="db_stat.html">db_stat(1)</A></STRONG>, <STRONG><A HREF="db_intro.html">db_intro(3)</A></STRONG>, <STRONG><A HREF="db_jump.html">db_jump(3)</A></STRONG>,
       <STRONG><A HREF="db_thread.html">db_thread(3)</A></STRONG>, <STRONG><A HREF="Db.html">Db(3)</A></STRONG>, <STRONG><A HREF="Dbc.html">Dbc(3)</A></STRONG>, <STRONG><A HREF="DbEnv.html">DbEnv(3)</A></STRONG>, <STRONG><A HREF="DbException.html">DbException(3)</A></STRONG>, <STRONG><A HREF="DbInfo.html">DbInfo(3)</A></STRONG>,
       <STRONG><A HREF="DbLock.html">DbLock(3)</A></STRONG>, <STRONG><A HREF="DbLocktab.html">DbLocktab(3)</A></STRONG>, <STRONG><A HREF="DbLog.html">DbLog(3)</A></STRONG>, <STRONG><A HREF="DbLsn.html">DbLsn(3)</A></STRONG>, <STRONG><A HREF="DbMpool.html">DbMpool(3)</A></STRONG>,
       <STRONG><A HREF="DbMpoolFile.html">DbMpoolFile(3)</A></STRONG>, <STRONG><A HREF="Dbt.html">Dbt(3)</A></STRONG>, <STRONG><A HREF="DbTxn.html">DbTxn(3)</A></STRONG>, <STRONG><A HREF="DbTxnMgr.html">DbTxnMgr(3)</A></STRONG>
</PRE>
</BODY>
</HTML>
